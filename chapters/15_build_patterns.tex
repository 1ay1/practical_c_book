\chapter{Build Patterns and Systems}

\section{The Real-World Build Problem}

Let me show you EXACTLY what happens when you build a real C project, step by step, and WHY each piece exists.

\textbf{Why real-world builds are confusing}:

When you clone a real C project and see \texttt{./configure \&\& make \&\& make install}, you're witnessing decades of evolved build practices. There's \texttt{configure.ac}, \texttt{Makefile.am}, \texttt{config.h.in}, \texttt{m4} macros, shell scripts, and generated files everywhere. It's overwhelming because each piece solves a specific historical problem:

\begin{itemize}
    \item \textbf{1970s}: Just compile all .c files
    \item \textbf{1980s}: Make tracks dependencies
    \item \textbf{1990s}: Autotools handles portability (different Unix flavors)
    \item \textbf{2000s}: pkg-config manages library dependencies
    \item \textbf{2010s}: CMake/Meson provide modern alternatives
    \item \textbf{2020s}: Containers and CI/CD automation
\end{itemize}

Each layer adds complexity, but also solves real problems. This chapter explains \textit{everything}—from the configure script you run to the installation paths hardcoded in the binary.

\subsection{The Problem: Write Once, Run Anywhere}

You write a C program on your Linux laptop. You want other people to compile it on:
\begin{itemize}
    \item Red Hat Enterprise Linux 7 (has GCC 4.8)
    \item Ubuntu 22.04 (has GCC 11)
    \item macOS 12 (has Clang)
    \item FreeBSD 13 (has Clang, different paths)
    \item Alpine Linux (has musl libc instead of glibc)
\end{itemize}

\textbf{Problems you'll hit}:

\begin{enumerate}
    \item \textbf{Different compilers}: GCC vs Clang, different versions, different flags
    \item \textbf{Different library locations}: OpenSSL might be in /usr/lib or /usr/local/lib or /opt/openssl
    \item \textbf{Different header locations}: headers in /usr/include or /usr/local/include
    \item \textbf{Missing functions}: Some systems have \texttt{strlcpy}, others don't
    \item \textbf{Different system calls}: Linux has \texttt{epoll}, macOS has \texttt{kqueue}, BSD has both
    \item \textbf{Feature availability}: Does this system have threading? IPv6? 64-bit file support?
\end{enumerate}

\textbf{The solution}: A configure script that TESTS the system and generates appropriate Makefiles. This is why every serious C project has \texttt{./configure}.

\subsection{Let's Build a Real Project: curl}

I'll show you exactly what happens when you build curl (the command-line HTTP client used by millions). We'll trace EVERY step.

\begin{lstlisting}
# Clone curl
git clone https://github.com/curl/curl.git
cd curl

# What files do you see?
ls -la

# You'll see:
configure.ac        # INPUT: autoconf reads this
Makefile.am         # INPUT: automake reads this
m4/                 # Directory of autoconf macros
src/                # Source code
lib/                # libcurl library
include/            # Headers
docs/               # Documentation
buildconf           # Script to generate configure
configure           # Generated by autoconf (if present)
Makefile.in         # Generated by automake (if present)
\end{lstlisting}

\textbf{Key insight}: Files ending in \texttt{.ac}, \texttt{.am}, \texttt{.in} are INPUTS. The \texttt{configure} script and \texttt{Makefile} are OUTPUTS.

\subsection{Step 1: Generate the Configure Script (Developer Only)}

If you cloned from git, there's no \texttt{configure} script yet. It must be generated:

\begin{lstlisting}
# Run buildconf (or autogen.sh in other projects)
./buildconf

# What does this do? Let's trace it:
# 1. Runs libtoolize (for building shared libraries)
# 2. Runs aclocal (collects m4 macros)
# 3. Runs autoconf (generates configure from configure.ac)
# 4. Runs automake (generates Makefile.in from Makefile.am)

# After this, you have:
configure           # Shell script (~40,000 lines!)
Makefile.in         # Makefile template
aclocal.m4          # Collected macros
config.h.in         # Config header template

# Users who download curl-7.x.tar.gz DON'T run this
# They get the configure script already generated
\end{lstlisting}

\textbf{Why this step?} The configure script is 40,000 lines of shell code. You don't write it by hand. autoconf generates it from configure.ac (which is ~3,000 lines of M4 macros).

\subsection{Step 2: Run Configure - The Magic Happens}

Now let's run configure and see EXACTLY what it does:

\begin{lstlisting}
# Run configure with verbose output
./configure --prefix=/usr/local 2>&1 | tee configure.log

# It prints:
checking for gcc... gcc
checking whether the C compiler works... yes
checking for C compiler default output file name... a.out
checking for suffix of executables...
checking whether we are cross compiling... no
checking for suffix of object files... o
checking whether the compiler supports GNU C... yes
checking for openssl/ssl.h... yes
checking for SSL_connect in -lssl... yes
checking for libz... yes
checking for pthread_create in -lpthread... yes
...hundreds more checks...
configure: creating ./config.status
config.status: creating Makefile
config.status: creating lib/Makefile
config.status: creating src/Makefile
config.status: creating lib/curl_config.h
configure: Configured to build curl/libcurl:
  Host system:     x86_64-pc-linux-gnu
  SSL support:     enabled (OpenSSL)
  SSH support:     enabled
  IPv6 support:    enabled
  Protocol:        HTTP/HTTPS/FTP/FTPS/SCP/SFTP...
\end{lstlisting}

\textbf{What just happened?} Let's break down each check:

\subsubsection{Check 1: Finding the C Compiler}

\begin{lstlisting}
# configure runs:
gcc -v
# Checks exit code. If success, GCC exists.

# Then it compiles a test program:
cat > conftest.c << EOF
int main(void) { return 0; }
EOF

gcc conftest.c -o conftest
# If this works, compiler is functional
rm -f conftest conftest.c

# Result: CC=gcc is set in the Makefile
\end{lstlisting}

\subsubsection{Check 2: Finding OpenSSL}

\begin{lstlisting}
# configure tries multiple methods:

# Method 1: Check if pkg-config knows about openssl
pkg-config --exists openssl
if [ $? -eq 0 ]; then
    OPENSSL_CFLAGS=$(pkg-config --cflags openssl)
    OPENSSL_LIBS=$(pkg-config --libs openssl)
fi

# Method 2: Try to compile a test program
cat > conftest.c << EOF
#include <openssl/ssl.h>
int main(void) { SSL_library_init(); return 0; }
EOF

# Try with default paths
gcc conftest.c -lssl -lcrypto -o conftest 2>/dev/null
if [ $? -eq 0 ]; then
    HAVE_OPENSSL=yes
fi

# Method 3: Search common locations
for dir in /usr /usr/local /opt/openssl; do
    if [ -f $dir/include/openssl/ssl.h ]; then
        OPENSSL_CFLAGS="-I$dir/include"
        OPENSSL_LIBS="-L$dir/lib -lssl -lcrypto"
        HAVE_OPENSSL=yes
        break
    fi
done

# Result: Either HAVE_OPENSSL=yes or HAVE_OPENSSL=no
# This gets written to config.h:
# #define HAVE_OPENSSL 1
\end{lstlisting}

\subsubsection{Check 3: Function Availability}

\begin{lstlisting}
# Check if strlcpy exists (BSD function not in glibc)
cat > conftest.c << EOF
#include <string.h>
int main(void) {
    char buf[10];
    strlcpy(buf, "test", sizeof(buf));
    return 0;
}
EOF

gcc conftest.c -o conftest 2>/dev/null
if [ $? -eq 0 ]; then
    # Function exists
    echo "#define HAVE_STRLCPY 1" >> config.h
else
    # Function missing - use fallback
    echo "/* #undef HAVE_STRLCPY */" >> config.h
fi

# In code, you use:
#ifdef HAVE_STRLCPY
    strlcpy(dest, src, size);
#else
    strncpy(dest, src, size - 1);
    dest[size - 1] = '\0';
#endif
\end{lstlisting}

\subsubsection{The Generated Files}

After configure finishes, you have:

\begin{lstlisting}
# config.h - System capabilities
#define HAVE_OPENSSL 1
#define HAVE_PTHREAD 1
#define HAVE_STRLCPY 1
#define HAVE_SYS_SELECT_H 1
/* #undef HAVE_KQUEUE */
#define SIZEOF_INT 4
#define SIZEOF_LONG 8

# Makefile - Build instructions
CC = gcc
CFLAGS = -O2 -Wall
LDFLAGS = -lssl -lcrypto -lpthread -lz
prefix = /usr/local
bindir = ${prefix}/bin
libdir = ${prefix}/lib

curl: src/main.o lib/libcurl.a
	$(CC) -o curl src/main.o -Llib -lcurl $(LDFLAGS)

src/main.o: src/main.c
	$(CC) $(CFLAGS) -Iinclude -c src/main.c -o src/main.o
\end{lstlisting}

\textbf{The key insight}: configure is a giant detection script. It doesn't compile anything—it just TESTS what's available and generates Makefiles tailored to YOUR system.

\subsection{Step 3: Run Make - Actual Compilation}

Now that we have a configured Makefile, let's compile:

\begin{lstlisting}
# Run make with verbose output
make V=1

# You'll see actual commands:
gcc -O2 -Wall -Iinclude -Ilib -c src/main.c -o src/main.o
gcc -O2 -Wall -Iinclude -Ilib -c src/tool_operate.c -o src/tool_operate.o
gcc -O2 -Wall -Iinclude -Ilib -c src/tool_urlglob.c -o src/tool_urlglob.o
...
gcc -O2 -Wall -Iinclude -c lib/url.c -o lib/url.o
gcc -O2 -Wall -Iinclude -c lib/http.c -o lib/http.o
...
ar rcs lib/libcurl.a lib/url.o lib/http.o lib/ftp.o ...
gcc -o src/curl src/main.o src/tool_operate.o ... -Llib -lcurl -lssl -lcrypto -lz -lpthread
\end{lstlisting}

\textbf{What just happened?}

\begin{enumerate}
    \item \textbf{Compiled source files to .o}: Each .c file becomes a .o (object file)
    \item \textbf{Built library}: All lib/*.o files bundled into libcurl.a with \texttt{ar}
    \item \textbf{Linked executable}: src/*.o files linked with libcurl.a and system libraries
\end{enumerate}

\textbf{Try changing one file}:

\begin{lstlisting}
# Modify one source file
echo "// comment" >> src/main.c

# Run make again
make

# Only compiles changed file and relinks:
gcc -O2 -Wall -Iinclude -Ilib -c src/main.c -o src/main.o
gcc -o src/curl src/main.o ... -Llib -lcurl -lssl -lcrypto -lz

# Make tracks dependencies with timestamps!
# main.o is newer than main.c? Skip compilation
# curl is older than main.o? Relink
\end{lstlisting}

\subsection{Step 4: Run Make Install - System Installation}

\begin{lstlisting}
# Install to /usr/local (requires root)
sudo make install

# What it does:
install -d /usr/local/bin
install -m 755 src/curl /usr/local/bin/curl
install -d /usr/local/lib
install -m 644 lib/libcurl.a /usr/local/lib/libcurl.a
install -m 755 lib/libcurl.so.4.8.0 /usr/local/lib/
ln -sf libcurl.so.4.8.0 /usr/local/lib/libcurl.so.4
ln -sf libcurl.so.4 /usr/local/lib/libcurl.so
install -d /usr/local/include/curl
install -m 644 include/curl/curl.h /usr/local/include/curl/
install -d /usr/local/lib/pkgconfig
install -m 644 libcurl.pc /usr/local/lib/pkgconfig/
install -d /usr/local/share/man/man1
install -m 644 docs/curl.1 /usr/local/share/man/man1/

# Update linker cache (Linux)
ldconfig
\end{lstlisting}

\textbf{Why these paths?}

\begin{itemize}
    \item \texttt{/usr/local/bin}: User-installed executables
    \item \texttt{/usr/local/lib}: User-installed libraries
    \item \texttt{/usr/local/include}: User-installed headers
    \item \texttt{/usr/local/share}: Data files (docs, man pages)
\end{itemize}

System packages use \texttt{/usr} (managed by package manager). You use \texttt{/usr/local} (manual installs).

\section{Why This System Exists - The Historical Problem}

\subsection{The Portability Nightmare (Pre-Autotools)}

In the 1980s-90s, Unix variants were incompatible:

\begin{lstlisting}
# Your program on different systems:

# SunOS (Sun Microsystems)
cc -I/usr/openwin/include -L/usr/openwin/lib -lX11 main.c

# AIX (IBM)
xlc -I/usr/lpp/X11/include -L/usr/lpp/X11/lib -lX11 main.c

# HP-UX (Hewlett-Packard)
cc -I/usr/include/X11R5 -L/usr/lib/X11R5 -lX11 main.c

# IRIX (SGI)
cc -I/usr/include/X11 -L/usr/lib32 -lX11 main.c
\end{lstlisting}

Every system had:
\begin{itemize}
    \item Different compiler names (cc, gcc, xlc, acc)
    \item Different library locations
    \item Different available functions
    \item Different system calls
\end{itemize}

\textbf{Solutions developers tried}:

\subsubsection{Attempt 1: Platform-Specific Makefiles}

\begin{lstlisting}
# Makefile.sunos
CC = cc
CFLAGS = -I/usr/openwin/include
LDFLAGS = -L/usr/openwin/lib -lX11

# Makefile.aix
CC = xlc
CFLAGS = -I/usr/lpp/X11/include
LDFLAGS = -L/usr/lpp/X11/lib -lX11

# Users had to choose:
make -f Makefile.sunos  # On SunOS
make -f Makefile.aix    # On AIX
\end{lstlisting}

\textbf{Problem}: Unmaintainable. 10 Unix variants = 10 Makefiles to maintain.

\subsubsection{Attempt 2: Imake (X11's Solution)}

\begin{lstlisting}
# Imakefile - High-level description
SRCS = main.c utils.c
OBJS = main.o utils.o
ComplexProgramTarget(myprogram)

# Run imake to generate Makefile
imake -DUseInstalled -I/usr/lib/X11/config

# Problem: Required X11 infrastructure everywhere
# Even if your program didn't use X11!
\end{lstlisting}

\subsubsection{Attempt 3: Autotools (The Winner)}

GNU invented autotools in the 1990s. Key insight:

\begin{quote}
Don't hardcode paths. TEST the system and generate appropriate Makefiles.
\end{quote}

\begin{lstlisting}
# User experience becomes universal:
./configure
make
make install

# Works on ANY Unix, even ones that didn't exist yet!
\end{lstlisting}

\section{Makefile Fundamentals}

Make is the oldest and most universal build tool. Every C programmer must know Make.

\subsection{Basic Makefile Structure}

\begin{lstlisting}
# Target: dependencies
#     commands (must be indented with TAB)

# Build executable
program: main.o utils.o
	gcc -o program main.o utils.o

# Compile main.c
main.o: main.c utils.h
	gcc -c main.c

# Compile utils.c
utils.o: utils.c utils.h
	gcc -c utils.c

# Clean build artifacts
clean:
	rm -f *.o program
\end{lstlisting}

\textbf{How Make works}:

\begin{enumerate}
    \item Make reads the Makefile
    \item You run \texttt{make target} (or just \texttt{make} for first target)
    \item Make checks if target exists and if dependencies are newer
    \item If target is out of date, Make runs the commands
    \item Make recursively builds dependencies first
\end{enumerate}

\subsection{Variables and Automatic Variables}

\begin{lstlisting}
# Variables
CC = gcc
CFLAGS = -Wall -Wextra -O2 -g
LDFLAGS = -lm -lpthread
OBJECTS = main.o utils.o parser.o

# Use variables
program: $(OBJECTS)
	$(CC) -o $@ $(OBJECTS) $(LDFLAGS)

# Pattern rule with automatic variables
%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

# Automatic variables:
# $@ = target name
# $< = first dependency
# $^ = all dependencies
# $* = stem of pattern match

# Example usage
main.o: main.c utils.h config.h
	$(CC) $(CFLAGS) -c $< -o $@
	# $< is main.c
	# $@ is main.o
	# $^ is main.c utils.h config.h
\end{lstlisting}

\subsection{Phony Targets}

\begin{lstlisting}
# Phony targets don't correspond to files
.PHONY: all clean install test

all: program

clean:
	rm -f $(OBJECTS) program

install: program
	install -m 755 program /usr/local/bin/

test: program
	./program --test
	./run_tests.sh

# Without .PHONY, if a file named "clean" exists,
# make would think target is up to date and skip it!
\end{lstlisting}

\subsection{Real-World Makefile}

\begin{lstlisting}
# Project configuration
PROJECT = myapp
VERSION = 1.0.0
PREFIX = /usr/local

# Compiler and flags
CC = gcc
CFLAGS = -Wall -Wextra -std=c11 -O2 -g
CFLAGS += -D_POSIX_C_SOURCE=200809L
CFLAGS += -DVERSION=\"$(VERSION)\"
LDFLAGS = -lm -lpthread

# Directories
SRCDIR = src
INCDIR = include
BUILDDIR = build
BINDIR = bin

# Source files
SOURCES = $(wildcard $(SRCDIR)/*.c)
OBJECTS = $(SOURCES:$(SRCDIR)/%.c=$(BUILDDIR)/%.o)
DEPENDS = $(OBJECTS:.o=.d)

# Main target
$(BINDIR)/$(PROJECT): $(OBJECTS) | $(BINDIR)
	$(CC) -o $@ $^ $(LDFLAGS)

# Compile with dependency generation
$(BUILDDIR)/%.o: $(SRCDIR)/%.c | $(BUILDDIR)
	$(CC) $(CFLAGS) -I$(INCDIR) -MMD -MP -c $< -o $@

# Create directories
$(BUILDDIR) $(BINDIR):
	mkdir -p $@

# Include auto-generated dependencies
-include $(DEPENDS)

# Phony targets
.PHONY: all clean install uninstall debug release test

all: $(BINDIR)/$(PROJECT)

clean:
	rm -rf $(BUILDDIR) $(BINDIR)

install: $(BINDIR)/$(PROJECT)
	install -d $(PREFIX)/bin
	install -m 755 $(BINDIR)/$(PROJECT) $(PREFIX)/bin/

uninstall:
	rm -f $(PREFIX)/bin/$(PROJECT)

debug: CFLAGS += -DDEBUG -O0 -g3
debug: clean all

release: CFLAGS += -DNDEBUG -O3 -march=native
release: LDFLAGS += -s
release: clean all

test: $(BINDIR)/$(PROJECT)
	$(BINDIR)/$(PROJECT) --run-tests

# Show configuration
info:
	@echo "Project: $(PROJECT) v$(VERSION)"
	@echo "CC: $(CC)"
	@echo "CFLAGS: $(CFLAGS)"
	@echo "LDFLAGS: $(LDFLAGS)"
	@echo "Sources: $(SOURCES)"
\end{lstlisting}

\textbf{Key features}:

\begin{itemize}
    \item Automatic dependency generation with \texttt{-MMD -MP}
    \item Separate source/build/bin directories
    \item Debug and release configurations
    \item Installation support
    \item Configurable prefix for different install locations
\end{itemize}

\section{Dependency Generation}

The hardest part of makefiles: tracking header dependencies automatically.

\subsection{The Problem}

\begin{lstlisting}
// main.c includes utils.h
#include "utils.h"

int main(void) {
    utility_function();
}

// If utils.h changes, main.c must be recompiled
// But how does Make know about this dependency?
\end{lstlisting}

\subsection{Manual Dependencies (Don't Do This)}

\begin{lstlisting}
# Manually list all header dependencies
main.o: main.c utils.h config.h types.h error.h

# Problem: Easy to get out of sync
# Add a new #include? Must update Makefile
# Remove an #include? Makefile still wrong
\end{lstlisting}

\subsection{Automatic Dependencies (The Right Way)}

\begin{lstlisting}
# Generate .d dependency files
%.o: %.c
	$(CC) $(CFLAGS) -MMD -MP -c $< -o $@

# Include them
-include $(OBJECTS:.o=.d)

# What this does:
# -MMD: Generate .d file with dependencies
# -MP: Add phony targets for headers (avoid errors if header deleted)

# Example generated main.d:
# main.o: main.c utils.h config.h
# utils.h:
# config.h:

# The phony targets prevent errors if you delete a header
\end{lstlisting}

\textbf{How it works}:

\begin{enumerate}
    \item First build: no .d files exist, so all .c files compile
    \item Compilation creates .d files listing each .o's dependencies
    \item Next build: Make includes .d files and knows the full dependency graph
    \item Change a header: Make recompiles all files that include it
\end{enumerate}

\section{Static and Dynamic Libraries}

Libraries package reusable code. Understanding them is crucial.

\subsection{Static Libraries (.a files)}

Linked into executable at compile time—becomes part of the binary.

\begin{lstlisting}
# Create static library
# Step 1: Compile to object files
gcc -c utils.c -o utils.o
gcc -c string_utils.c -o string_utils.o
gcc -c math_utils.c -o math_utils.o

# Step 2: Create archive
ar rcs libmyutils.a utils.o string_utils.o math_utils.o
# r = insert/replace
# c = create archive
# s = create symbol index

# Use static library
gcc main.c -L. -lmyutils -o program
# -L. = look for libraries in current directory
# -lmyutils = link libmyutils.a

# In Makefile:
libmyutils.a: utils.o string_utils.o math_utils.o
	ar rcs $@ $^

program: main.o libmyutils.a
	$(CC) -o $@ main.o -L. -lmyutils
\end{lstlisting}

\textbf{Static library advantages}:
\begin{itemize}
    \item No runtime dependencies—program is self-contained
    \item Slightly faster (no dynamic linking overhead)
    \item Easier deployment (one file)
\end{itemize}

\textbf{Disadvantages}:
\begin{itemize}
    \item Larger executables (library code copied in)
    \item No shared memory (each program has own copy)
    \item Must recompile programs to update library
\end{itemize}

\subsection{Dynamic Libraries (.so on Linux, .dylib on macOS, .dll on Windows)}

Loaded at runtime—shared between programs.

\begin{lstlisting}
# Create shared library
gcc -fPIC -c utils.c -o utils.o
gcc -fPIC -c string_utils.c -o string_utils.o
# -fPIC = Position Independent Code (required for shared libraries)

gcc -shared -o libmyutils.so utils.o string_utils.o
# -shared = create shared library

# Use shared library
gcc main.c -L. -lmyutils -o program

# Run program
LD_LIBRARY_PATH=. ./program
# LD_LIBRARY_PATH tells loader where to find .so files

# Or install to system location
sudo cp libmyutils.so /usr/local/lib/
sudo ldconfig  # Update linker cache

# In Makefile:
libmyutils.so: utils.o string_utils.o
	$(CC) -shared -o $@ $^

%.o: %.c
	$(CC) $(CFLAGS) -fPIC -c $< -o $@

program: main.o libmyutils.so
	$(CC) -o $@ main.o -L. -lmyutils -Wl,-rpath,'$$ORIGIN'
	# -Wl,-rpath,'$$ORIGIN' = look for .so in same directory as executable
\end{lstlisting}

\textbf{Dynamic library advantages}:
\begin{itemize}
    \item Smaller executables
    \item Shared memory (one copy in RAM for all programs)
    \item Update library without recompiling programs
    \item Plugin systems possible
\end{itemize}

\textbf{Disadvantages}:
\begin{itemize}
    \item Runtime dependencies—must have .so installed
    \item Slightly slower (dynamic linking overhead)
    \item Version conflicts ("DLL hell")
    \item More complex deployment
\end{itemize}

\subsection{Symbol Visibility}

Control what symbols are exported from libraries:

\begin{lstlisting}
// Library header - myutils.h
#ifndef MYUTILS_H
#define MYUTILS_H

// Public API - visible to users
#ifdef _WIN32
    #define API_EXPORT __declspec(dllexport)
#else
    #define API_EXPORT __attribute__((visibility("default")))
#endif

API_EXPORT int public_function(int x);

// Private function - not visible outside library
int internal_function(int x);

#endif

// Implementation - myutils.c
#include "myutils.h"

// This is exported
int public_function(int x) {
    return internal_function(x) * 2;
}

// This is hidden
static int internal_function(int x) {
    return x + 1;
}

// Compile with hidden visibility by default
gcc -fPIC -fvisibility=hidden -c myutils.c

// Only functions marked API_EXPORT are visible
\end{lstlisting}

\textbf{Why hide symbols?}

\begin{itemize}
    \item Smaller library size
    \item Faster loading
    \item Avoid symbol conflicts
    \item Clear API boundary
\end{itemize}

\section{Compiler Flags Deep Dive}

Flags dramatically affect your program's behavior and performance.

\subsection{Warning Flags (Always Use These)}

\begin{lstlisting}
# Essential warnings
CFLAGS = -Wall -Wextra -Werror
# -Wall = enable common warnings
# -Wextra = enable extra warnings
# -Werror = treat warnings as errors

# More warnings (stricter)
CFLAGS += -Wpedantic         # Strict ISO C
CFLAGS += -Wshadow           # Variable shadowing
CFLAGS += -Wconversion       # Implicit conversions
CFLAGS += -Wcast-align       # Pointer casts increase alignment
CFLAGS += -Wstrict-prototypes  # Functions without prototypes
CFLAGS += -Wmissing-prototypes # Global functions without prototypes
CFLAGS += -Wformat=2         # printf format checking
CFLAGS += -Wunused           # Unused variables/functions

# Paranoid mode (for critical code)
CFLAGS += -Wcast-qual        # Cast away const
CFLAGS += -Wwrite-strings    # String literals are const
CFLAGS += -Wundef            # Undefined macros in #if
CFLAGS += -Wredundant-decls  # Redundant declarations
CFLAGS += -Wdouble-promotion # Float promoted to double
\end{lstlisting}

\subsection{Optimization Flags}

\begin{lstlisting}
# Optimization levels
-O0  # No optimization (default) - fastest compile
-O1  # Basic optimization
-O2  # Recommended for release - good speed, reasonable compile time
-O3  # Aggressive optimization - may increase code size
-Os  # Optimize for size
-Og  # Optimize for debugging experience

# Debug build
CFLAGS_DEBUG = -O0 -g3 -DDEBUG
# -g3 = maximum debug info (includes macros)

# Release build
CFLAGS_RELEASE = -O2 -DNDEBUG
# -DNDEBUG disables assert()

# Maximum performance (benchmark carefully!)
CFLAGS_FAST = -O3 -march=native -flto
# -march=native = use all CPU features available
# -flto = Link Time Optimization

# Size optimization (embedded systems)
CFLAGS_SMALL = -Os -ffunction-sections -fdata-sections
LDFLAGS_SMALL = -Wl,--gc-sections
# Separate each function/data into sections
# Linker removes unused sections
\end{lstlisting}

\textbf{Warning}: \texttt{-O3} and \texttt{-march=native} can break code that relies on undefined behavior. Always test thoroughly!

\subsection{Architecture and Platform Flags}

\begin{lstlisting}
# Target specific architecture
-m32                    # 32-bit x86
-m64                    # 64-bit x86-64
-march=armv7-a          # ARMv7
-march=native           # Optimize for build machine's CPU

# Position Independent Code (required for shared libraries)
-fPIC                   # Position Independent Code
-fPIE                   # Position Independent Executable (for ASLR)

# Platform defines
-D_POSIX_C_SOURCE=200809L  # POSIX 2008
-D_GNU_SOURCE             # GNU extensions
-D_BSD_SOURCE             # BSD extensions
-D_DEFAULT_SOURCE         # Default features

# Threading
-pthread                  # Enable pthread support
\end{lstlisting}

\subsection{Security Flags}

\begin{lstlisting}
# Security hardening
CFLAGS_SECURE = -fstack-protector-strong  # Stack smashing protection
CFLAGS_SECURE += -D_FORTIFY_SOURCE=2      # Buffer overflow detection
CFLAGS_SECURE += -fPIE                    # Position independent executable

LDFLAGS_SECURE = -Wl,-z,relro             # Read-only relocations
LDFLAGS_SECURE += -Wl,-z,now              # Resolve all symbols at startup
LDFLAGS_SECURE += -pie                    # Create PIE executable

# Full security (Debian/Ubuntu style)
CFLAGS += $(CFLAGS_SECURE)
LDFLAGS += $(LDFLAGS_SECURE)
\end{lstlisting}

\section{Cross-Compilation}

Compiling for a different platform (e.g., compiling for ARM on x86).

\subsection{Cross-Compiler Setup}

\begin{lstlisting}
# Install cross-compiler
sudo apt-get install gcc-arm-linux-gnueabihf

# Cross-compile for ARM
CC = arm-linux-gnueabihf-gcc
AR = arm-linux-gnueabihf-ar
STRIP = arm-linux-gnueabihf-strip

# Build for ARM
arm-linux-gnueabihf-gcc -o program main.c

# Makefile for cross-compilation
ifeq ($(TARGET),arm)
    CC = arm-linux-gnueabihf-gcc
    CFLAGS += -march=armv7-a
else ifeq ($(TARGET),win32)
    CC = i686-w64-mingw32-gcc
    EXE = .exe
else
    CC = gcc
    EXE =
endif

program$(EXE): main.c
	$(CC) $(CFLAGS) -o $@ $<

# Usage:
# make                # Native build
# make TARGET=arm     # ARM build
# make TARGET=win32   # Windows build
\end{lstlisting}

\subsection{Toolchain Files}

For complex cross-compilation, use a toolchain file:

\begin{lstlisting}
# arm-toolchain.cmake (for CMake)
set(CMAKE_SYSTEM_NAME Linux)
set(CMAKE_SYSTEM_PROCESSOR arm)

set(CMAKE_C_COMPILER arm-linux-gnueabihf-gcc)
set(CMAKE_CXX_COMPILER arm-linux-gnueabihf-g++)

set(CMAKE_FIND_ROOT_PATH /usr/arm-linux-gnueabihf)
set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)

# Usage: cmake -DCMAKE_TOOLCHAIN_FILE=arm-toolchain.cmake ..
\end{lstlisting}

\section{Multi-Directory Projects}

Real projects have multiple subdirectories.

\subsection{Recursive Make}

\begin{lstlisting}
# Top-level Makefile
SUBDIRS = src lib tests

.PHONY: all clean $(SUBDIRS)

all: $(SUBDIRS)

$(SUBDIRS):
	$(MAKE) -C $@

clean:
	for dir in $(SUBDIRS); do \
		$(MAKE) -C $$dir clean; \
	done

# src/Makefile
SOURCES = main.c utils.c
OBJECTS = $(SOURCES:.c=.o)

all: program

program: $(OBJECTS)
	$(CC) -o $@ $^ -L../lib -lmylib

clean:
	rm -f $(OBJECTS) program
\end{lstlisting}

\textbf{Problem}: Recursive make is slow—each subdirectory is a separate make invocation, can't parallelize efficiently.

\subsection{Non-Recursive Make (Better)}

\begin{lstlisting}
# Single Makefile for entire project
SRCDIR = src
LIBDIR = lib
TESTDIR = tests

SOURCES = $(SRCDIR)/main.c $(SRCDIR)/utils.c
LIB_SOURCES = $(LIBDIR)/mylib.c
TEST_SOURCES = $(TESTDIR)/test_main.c

OBJECTS = $(SOURCES:.c=.o)
LIB_OBJECTS = $(LIB_SOURCES:.c=.o)
TEST_OBJECTS = $(TEST_SOURCES:.c=.o)

all: $(SRCDIR)/program

$(SRCDIR)/program: $(OBJECTS) $(LIBDIR)/libmylib.a
	$(CC) -o $@ $(OBJECTS) -L$(LIBDIR) -lmylib

$(LIBDIR)/libmylib.a: $(LIB_OBJECTS)
	ar rcs $@ $^

$(TESTDIR)/tests: $(TEST_OBJECTS) $(LIBDIR)/libmylib.a
	$(CC) -o $@ $(TEST_OBJECTS) -L$(LIBDIR) -lmylib

# Pattern rules work across all directories
%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

# Parallel build works: make -j8
\end{lstlisting}

\section{Build System Generators}

Hand-written Makefiles are tedious. Build generators simplify multi-platform builds.

\subsection{CMake}

The most popular C build system generator:

\begin{lstlisting}
# CMakeLists.txt
cmake_minimum_required(VERSION 3.10)
project(MyProject VERSION 1.0.0 LANGUAGES C)

# Set C standard
set(CMAKE_C_STANDARD 11)
set(CMAKE_C_STANDARD_REQUIRED ON)

# Compiler flags
add_compile_options(-Wall -Wextra)

# Find dependencies
find_package(Threads REQUIRED)

# Library
add_library(myutils STATIC
    src/utils.c
    src/string_utils.c
)
target_include_directories(myutils PUBLIC include)

# Executable
add_executable(program
    src/main.c
)
target_link_libraries(program PRIVATE myutils Threads::Threads)

# Install
install(TARGETS program DESTINATION bin)
install(TARGETS myutils DESTINATION lib)
install(DIRECTORY include/ DESTINATION include)

# Tests
enable_testing()
add_executable(tests test/test_main.c)
target_link_libraries(tests PRIVATE myutils)
add_test(NAME MainTests COMMAND tests)

# Build:
# mkdir build
# cd build
# cmake ..
# make
# make test
# make install
\end{lstlisting}

\subsection{Meson (Modern Alternative)}

\begin{lstlisting}
# meson.build
project('myproject', 'c',
  version: '1.0.0',
  default_options: ['c_std=c11', 'warning_level=3'])

# Library
myutils_lib = static_library('myutils',
  'src/utils.c',
  'src/string_utils.c',
  include_directories: include_directories('include'))

# Executable
executable('program',
  'src/main.c',
  link_with: myutils_lib,
  dependencies: dependency('threads'),
  install: true)

# Tests
test_exe = executable('tests',
  'test/test_main.c',
  link_with: myutils_lib)

test('main tests', test_exe)

# Build:
# meson setup build
# cd build
# ninja
# ninja test
# ninja install
\end{lstlisting}

\section{Practical Build Patterns}

\subsection{Out-of-Tree Builds}

Never build in source directory—keeps source tree clean:

\begin{lstlisting}
# Bad: build in source tree
$ make
# Creates .o files mixed with .c files

# Good: separate build directory
$ mkdir build
$ cd build
$ cmake ..
$ make

# Or with plain make:
BUILDDIR = build
SRCDIR = src

$(BUILDDIR)/%.o: $(SRCDIR)/%.c | $(BUILDDIR)
	$(CC) $(CFLAGS) -c $< -o $@

$(BUILDDIR):
	mkdir -p $@

clean:
	rm -rf $(BUILDDIR)
\end{lstlisting}

\subsection{Multiple Configurations}

\begin{lstlisting}
# Makefile supporting debug/release configs
CONFIG ?= release

ifeq ($(CONFIG),debug)
    CFLAGS = -O0 -g3 -DDEBUG
    OUTDIR = build/debug
else ifeq ($(CONFIG),release)
    CFLAGS = -O2 -DNDEBUG
    OUTDIR = build/release
else
    $(error Unknown configuration: $(CONFIG))
endif

$(OUTDIR)/program: $(OUTDIR)/main.o
	$(CC) -o $@ $^

$(OUTDIR)/%.o: src/%.c | $(OUTDIR)
	$(CC) $(CFLAGS) -c $< -o $@

$(OUTDIR):
	mkdir -p $@

# Usage:
# make CONFIG=debug
# make CONFIG=release
\end{lstlisting}

\subsection{Parallel Builds}

\begin{lstlisting}
# Automatic parallel builds
MAKEFLAGS += -j$(shell nproc)

# Or manually:
make -j8  # Use 8 parallel jobs

# CMake parallel builds
cmake --build . -j8

# In Makefile, ensure proper dependencies!
# Bad: race condition
all:
	gcc -c main.c
	gcc -c utils.c
	gcc -o program main.o utils.o  # May run before .o files ready!

# Good: explicit dependencies
all: program

program: main.o utils.o
	gcc -o program main.o utils.o

main.o: main.c
	gcc -c main.c

utils.o: utils.c
	gcc -c utils.c
\end{lstlisting}

\subsection{Dependency Vendoring}

Include third-party libraries in your source tree:

\begin{lstlisting}
# Project structure:
myproject/
+-- src/
+-- include/
+-- vendor/          # Third-party code
    +-- sqlite/
        +-- sqlite3.c
        +-- sqlite3.h
    +-- zlib/
        +-- zlib.c
        +-- zlib.h
+-- Makefile

# Makefile includes vendor code
VENDOR_SOURCES = vendor/sqlite/sqlite3.c vendor/zlib/zlib.c
SOURCES = src/main.c src/utils.c
ALL_SOURCES = $(SOURCES) $(VENDOR_SOURCES)

program: $(ALL_SOURCES:.c=.o)
	$(CC) -o $@ $^

# Advantages:
# - No external dependencies
# - Controlled versions
# - Easy to patch
# - Reproducible builds

# Disadvantages:
# - Larger repository
# - Must manually update vendor code
\end{lstlisting}

\section{Package Configuration}

Use pkg-config for finding libraries:

\begin{lstlisting}
# Find library flags
CFLAGS += $(shell pkg-config --cflags gtk+-3.0)
LDFLAGS += $(shell pkg-config --libs gtk+-3.0)

# Check if package exists
ifeq ($(shell pkg-config --exists openssl && echo yes),yes)
    CFLAGS += $(shell pkg-config --cflags openssl) -DHAVE_OPENSSL
    LDFLAGS += $(shell pkg-config --libs openssl)
endif

# In CMake:
find_package(PkgConfig REQUIRED)
pkg_check_modules(GTK3 REQUIRED gtk+-3.0)

target_include_directories(program PRIVATE ${GTK3_INCLUDE_DIRS})
target_link_libraries(program PRIVATE ${GTK3_LIBRARIES})

# Create .pc file for your library
# mylib.pc.in
prefix=@PREFIX@
libdir=${prefix}/lib
includedir=${prefix}/include

Name: mylib
Description: My utility library
Version: @VERSION@
Libs: -L${libdir} -lmylib
Cflags: -I${includedir}
\end{lstlisting}

\section{Build Optimization Techniques}

\subsection{Precompiled Headers}

Speed up compilation by precompiling common headers:

\begin{lstlisting}
# Create precompiled header
gcc -c common.h -o common.h.gch

# Use it (automatic if common.h.gch exists)
gcc -include common.h main.c

# In Makefile:
PCH = include/common.h.gch

$(PCH): include/common.h
	$(CC) $(CFLAGS) -c $< -o $@

%.o: %.c $(PCH)
	$(CC) $(CFLAGS) -include include/common.h -c $< -o $@

# Can save 20-50% compile time for large projects
\end{lstlisting}

\subsection{Unity Builds}

Compile all sources as one translation unit:

\begin{lstlisting}
# unity.c - includes all sources
#include "src/main.c"
#include "src/utils.c"
#include "src/parser.c"
#include "src/database.c"

# Compile everything at once
gcc -O2 unity.c -o program

# Much faster compilation (but loses incremental builds)
# Enables better optimization across translation units
# Use for release builds, not development
\end{lstlisting}

\subsection{Ccache - Compiler Cache}

Cache compilation results:

\begin{lstlisting}
# Install ccache
sudo apt-get install ccache

# Use it
CC = ccache gcc

# Or set in CMake
find_program(CCACHE_PROGRAM ccache)
if(CCACHE_PROGRAM)
    set(CMAKE_C_COMPILER_LAUNCHER "${CCACHE_PROGRAM}")
endif()

# First build: normal speed
# Rebuild after 'make clean': instant (from cache)
# Saves huge amounts of time in CI/CD
\end{lstlisting}

\section{Continuous Integration}

Automate builds and tests:

\subsection{GitHub Actions}

\begin{lstlisting}
# .github/workflows/build.yml
name: Build

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2

    - name: Install dependencies
      run: sudo apt-get install -y libssl-dev

    - name: Build
      run: |
        mkdir build
        cd build
        cmake ..
        make

    - name: Test
      run: cd build && make test

    - name: Upload artifacts
      uses: actions/upload-artifact@v2
      with:
        name: program
        path: build/program
\end{lstlisting}

\subsection{Docker Builds}

Reproducible build environments:

\begin{lstlisting}
# Dockerfile
FROM gcc:11

WORKDIR /app
COPY . .

RUN apt-get update && apt-get install -y cmake

RUN mkdir build && cd build && cmake .. && make

CMD ["./build/program"]

# Build in Docker
docker build -t myprogram .
docker run myprogram
\end{lstlisting}

\section{Troubleshooting Build Problems}

\subsection{Verbose Builds}

\begin{lstlisting}
# See actual commands
make V=1

# CMake verbose
make VERBOSE=1

# Or set in CMakeLists.txt
set(CMAKE_VERBOSE_MAKEFILE ON)
\end{lstlisting}

\subsection{Common Linker Errors}

\begin{lstlisting}
# Undefined reference
# Problem: Missing implementation or library
main.c:10: undefined reference to `foo'

# Solutions:
# 1. Missing .o file
gcc main.o foo.o  # Include foo.o

# 2. Missing library
gcc main.o -lfoo  # Link libfoo.a or libfoo.so

# 3. Wrong link order (static libraries)
gcc main.o -lbar -lfoo  # Wrong!
gcc main.o -lfoo -lbar  # Correct - foo depends on bar

# Multiple definitions
# Problem: Same symbol defined in multiple .o files
foo.o: multiple definition of `global_var'
bar.o: first defined here

# Solution: Use 'extern' or 'static'

# Library not found
/usr/bin/ld: cannot find -lfoo

# Solutions:
# 1. Add library path
gcc main.o -L/path/to/lib -lfoo

# 2. Install library
sudo apt-get install libfoo-dev

# 3. Set LD_LIBRARY_PATH
export LD_LIBRARY_PATH=/path/to/lib
\end{lstlisting}

\section{Deep Dive: Reading a Real configure.ac}

Let's read curl's actual configure.ac line by line and understand EVERY part.

\subsection{The Header Section}

\begin{lstlisting}
# configure.ac (first 50 lines)

AC_PREREQ(2.57)
# Requires autoconf version 2.57 or later

AC_INIT([curl], [7.88.0], [curl-bug@haxx.se])
# Sets package name, version, bug report email

AC_CONFIG_SRCDIR([lib/curl.c])
# Sanity check - this file must exist (we're in right directory)

AC_CONFIG_HEADERS([lib/curl_config.h])
# Generate lib/curl_config.h from lib/curl_config.h.in

AM_INIT_AUTOMAKE([foreign no-define])
# Initialize automake
# "foreign" = don't require GNU files (NEWS, AUTHORS, etc.)
# "no-define" = don't add -DPACKAGE -DVERSION to every compile

AC_PROG_CC
# Find the C compiler (tries gcc, cc, clang in order)
# Sets $(CC) variable

AC_PROG_INSTALL
# Find install program
# Sets $(INSTALL) variable

AC_PROG_LN_S
# Find ln -s command (or fallback on Windows)
# Sets $(LN_S) variable
\end{lstlisting}

\subsection{System Detection}

\begin{lstlisting}
AC_CANONICAL_HOST
# Detects the system triplet: CPU-VENDOR-OS
# Examples:
#   x86_64-pc-linux-gnu
#   x86_64-apple-darwin21
#   aarch64-unknown-linux-gnu
#   i686-w64-mingw32

# Now we can check the OS:
case $host_os in
  linux*)
    # Linux-specific code
    AC_DEFINE([OS_LINUX], [1], [Linux])
    ;;
  darwin*)
    # macOS-specific code
    AC_DEFINE([OS_DARWIN], [1], [macOS])
    # macOS uses different SSL library
    LIBS="$LIBS -framework CoreFoundation -framework Security"
    ;;
  mingw*)
    # Windows-specific code
    AC_DEFINE([OS_WINDOWS], [1], [Windows])
    LIBS="$LIBS -lws2_32"  # Windows sockets
    ;;
esac
\end{lstlisting}

\subsection{Feature Detection - The Heart of Configure}

\begin{lstlisting}
# Check for header files
AC_CHECK_HEADERS([
  sys/socket.h
  netinet/in.h
  arpa/inet.h
  sys/select.h
  sys/epoll.h
  sys/event.h
  windows.h
])

# What this does:
# For each header, generates and compiles:
cat > conftest.c << EOF
#include <sys/socket.h>
int main(void) { return 0; }
EOF
gcc -c conftest.c 2>/dev/null
# If success: #define HAVE_SYS_SOCKET_H 1
# If failure: /* #undef HAVE_SYS_SOCKET_H */

# Check for functions
AC_CHECK_FUNCS([
  socket
  select
  poll
  epoll_create
  kqueue
  strlcpy
  strlcat
  getaddrinfo
  gethostbyname
])

# For each function:
cat > conftest.c << EOF
int main(void) {
  void *p = (void*)socket;
  return (int)(long)p;
}
EOF
gcc conftest.c -o conftest 2>/dev/null
# If links successfully: #define HAVE_SOCKET 1

# Check for libraries
AC_CHECK_LIB([z], [inflate], [
  AC_DEFINE([HAVE_ZLIB], [1], [zlib available])
  LIBS="$LIBS -lz"
], [
  AC_MSG_WARN([zlib not found - compression disabled])
])

# What this does:
cat > conftest.c << EOF
extern int inflate();
int main(void) { inflate(); return 0; }
EOF
gcc conftest.c -lz -o conftest 2>/dev/null
# If links: HAVE_ZLIB=1, add -lz to LIBS
\end{lstlisting}

\subsection{Optional Features (--enable / --disable)}

\begin{lstlisting}
# Add a --enable-debug option
AC_ARG_ENABLE([debug],
  [AS_HELP_STRING([--enable-debug],
    [Enable debug build (default: no)])],
  [enable_debug=$enableval],
  [enable_debug=no])

# This creates:
# ./configure --enable-debug    -> enable_debug=yes
# ./configure --disable-debug   -> enable_debug=no
# ./configure (no flag)         -> enable_debug=no (default)

# Use the option:
if test "x$enable_debug" = "xyes"; then
  CFLAGS="$CFLAGS -g -O0 -DDEBUG"
  AC_DEFINE([DEBUG_BUILD], [1], [Debug build])
else
  CFLAGS="$CFLAGS -O2 -DNDEBUG"
fi

# Real example from curl - IPv6 support:
AC_ARG_ENABLE([ipv6],
  [AS_HELP_STRING([--enable-ipv6],
    [Enable IPv6 support (default: auto)])],
  [enable_ipv6=$enableval],
  [enable_ipv6=auto])

if test "x$enable_ipv6" != "xno"; then
  # Try to compile IPv6 test program
  AC_MSG_CHECKING([for IPv6 support])
  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
    #include <sys/socket.h>
    #include <netinet/in.h>
  ]], [[
    struct sockaddr_in6 sa;
    sa.sin6_family = AF_INET6;
  ]])], [
    AC_MSG_RESULT([yes])
    AC_DEFINE([ENABLE_IPV6], [1], [IPv6 enabled])
    have_ipv6=yes
  ], [
    AC_MSG_RESULT([no])
    if test "x$enable_ipv6" = "xyes"; then
      AC_MSG_ERROR([IPv6 requested but not available])
    fi
    have_ipv6=no
  ])
fi
\end{lstlisting}

\subsection{External Dependencies (--with / --without)}

\begin{lstlisting}
# SSL library selection
AC_ARG_WITH([ssl],
  [AS_HELP_STRING([--with-ssl=PATH],
    [Use OpenSSL (in PATH)])],
  [want_ssl=$withval],
  [want_ssl=yes])

if test "x$want_ssl" != "xno"; then
  # If path specified, look there first
  if test "x$want_ssl" != "xyes"; then
    CPPFLAGS="$CPPFLAGS -I$want_ssl/include"
    LDFLAGS="$LDFLAGS -L$want_ssl/lib"
  fi

  # Try pkg-config first
  PKG_CHECK_MODULES([OPENSSL], [openssl >= 1.0.0], [
    AC_DEFINE([HAVE_OPENSSL], [1], [OpenSSL available])
    LIBS="$LIBS $OPENSSL_LIBS"
    CFLAGS="$CFLAGS $OPENSSL_CFLAGS"
    have_ssl=yes
  ], [
    # pkg-config failed, try manual detection
    AC_CHECK_HEADERS([openssl/ssl.h], [
      AC_CHECK_LIB([ssl], [SSL_connect], [
        AC_DEFINE([HAVE_OPENSSL], [1])
        LIBS="$LIBS -lssl -lcrypto"
        have_ssl=yes
      ], [
        have_ssl=no
      ], [-lcrypto])
    ], [
      have_ssl=no
    ])
  ])

  # If required but not found, error
  if test "x$have_ssl" = "xno" && test "x$want_ssl" = "xyes"; then
    AC_MSG_ERROR([
      OpenSSL not found. Install libssl-dev or use:
      --without-ssl     (disable SSL support)
      --with-ssl=PATH   (specify OpenSSL location)
    ])
  fi
fi
\end{lstlisting}

\subsection{Generating Output Files}

\begin{lstlisting}
# List all files to generate
AC_CONFIG_FILES([
  Makefile
  lib/Makefile
  src/Makefile
  tests/Makefile
  docs/Makefile
  libcurl.pc
])

# Actually generate them
AC_OUTPUT

# At end, configure prints summary:
echo ""
echo "configure: Configured to build curl/libcurl:"
echo ""
echo "  Host setup:       $host"
echo "  Install prefix:   $prefix"
echo "  Compiler:         $CC"
echo "  CFLAGS:          $CFLAGS"
echo "  LDFLAGS:         $LDFLAGS"
echo "  LIBS:            $LIBS"
echo ""
echo "  SSL support:     $have_ssl"
echo "  IPv6 support:    $have_ipv6"
echo "  HTTP support:    yes"
echo "  HTTPS support:   $have_ssl"
echo ""
\end{lstlisting}

\textbf{The complete flow}:

\begin{enumerate}
    \item Developer writes configure.ac (~3,000 lines of M4 macros)
    \item \texttt{autoconf} reads configure.ac
    \item \texttt{autoconf} generates configure (~40,000 lines of shell script)
    \item Developer distributes configure (users don't need autoconf!)
    \item User runs \texttt{./configure}
    \item configure tests the system
    \item configure generates Makefile and config.h
    \item User runs \texttt{make}
\end{enumerate}

\subsection{Autotools: The Full Pipeline}

Autotools is actually three tools that work together:

\begin{lstlisting}
# 1. autoconf - generates configure script
autoconf
# Reads: configure.ac
# Generates: configure

# 2. automake - generates Makefile.in templates
automake --add-missing
# Reads: Makefile.am
# Generates: Makefile.in

# 3. configure - generates actual Makefiles
./configure
# Reads: Makefile.in, config.h.in
# Generates: Makefile, config.h

# The developer workflow:
# Write configure.ac and Makefile.am
# Run: autoreconf -i (runs autoconf + automake)
# Distribute: configure script (users don't need autotools!)
# Users run: ./configure && make
\end{lstlisting}

\subsection{Simple configure.ac Example}

This is what project maintainers write:

\begin{lstlisting}
# configure.ac - Input for autoconf
AC_INIT([myproject], [1.0.0], [bug-report@example.com])
AM_INIT_AUTOMAKE([-Wall -Werror foreign])
AC_PROG_CC
AC_CONFIG_HEADERS([config.h])
AC_CONFIG_FILES([Makefile src/Makefile])

# Check for required headers
AC_CHECK_HEADERS([stdlib.h string.h unistd.h])

# Check for required functions
AC_CHECK_FUNCS([malloc realloc memset])

# Check for libraries
AC_CHECK_LIB([pthread], [pthread_create])
AC_CHECK_LIB([m], [sqrt])

# Optional features
AC_ARG_ENABLE([debug],
    AS_HELP_STRING([--enable-debug], [Enable debug mode]),
    [enable_debug=yes],
    [enable_debug=no])

AS_IF([test "x$enable_debug" = "xyes"], [
    AC_DEFINE([DEBUG], [1], [Debug mode enabled])
    CFLAGS="$CFLAGS -g -O0"
], [
    CFLAGS="$CFLAGS -O2 -DNDEBUG"
])

# Optional dependencies
AC_ARG_WITH([openssl],
    AS_HELP_STRING([--with-openssl], [Build with OpenSSL support]),
    [],
    [with_openssl=check])

AS_IF([test "x$with_openssl" != "xno"], [
    PKG_CHECK_MODULES([OPENSSL], [openssl >= 1.1.0], [
        AC_DEFINE([HAVE_OPENSSL], [1], [OpenSSL available])
        have_openssl=yes
    ], [
        AS_IF([test "x$with_openssl" = "xyes"], [
            AC_MSG_ERROR([OpenSSL requested but not found])
        ])
        have_openssl=no
    ])
])

AC_OUTPUT

# Summary message
echo ""
echo "Configuration summary:"
echo "  Prefix: $prefix"
echo "  Debug mode: $enable_debug"
echo "  OpenSSL: $have_openssl"
echo ""
\end{lstlisting}

\subsection{Makefile.am - Automake Input}

Much simpler than raw Makefiles:

\begin{lstlisting}
# Makefile.am - High-level description
bin_PROGRAMS = myprogram
myprogram_SOURCES = main.c utils.c parser.c
myprogram_CFLAGS = $(OPENSSL_CFLAGS)
myprogram_LDADD = $(OPENSSL_LIBS) -lpthread

# Build a library
lib_LTLIBRARIES = libmylib.la
libmylib_la_SOURCES = lib.c helper.c
libmylib_la_LDFLAGS = -version-info 1:0:0

# Install headers
include_HEADERS = mylib.h

# Subdirectories
SUBDIRS = src tests docs

# Extra files to distribute
EXTRA_DIST = README.md LICENSE example.conf

# Tests
TESTS = tests/test_basic tests/test_advanced
check_PROGRAMS = $(TESTS)
\end{lstlisting}

\textbf{Automake magic variables}:
\begin{itemize}
    \item \texttt{bin\_PROGRAMS}: Executables installed to \$prefix/bin
    \item \texttt{lib\_LTLIBRARIES}: Libraries (libtool handles portability)
    \item \texttt{include\_HEADERS}: Headers installed to \$prefix/include
    \item \texttt{\_SOURCES}: Source files
    \item \texttt{\_CFLAGS}: Additional compiler flags
    \item \texttt{\_LDADD}: Libraries to link
\end{itemize}

\subsection{Generated config.h}

Configuration results go into config.h:

\begin{lstlisting}
/* config.h.in - Template */
#undef HAVE_STDLIB_H
#undef HAVE_PTHREAD
#undef HAVE_OPENSSL
#undef DEBUG
#define VERSION "@VERSION@"
#define PACKAGE "@PACKAGE@"

/* config.h - Generated by configure */
#define HAVE_STDLIB_H 1
#define HAVE_PTHREAD 1
#define HAVE_OPENSSL 1
/* #undef DEBUG */
#define VERSION "1.0.0"
#define PACKAGE "myproject"

/* Usage in code */
#include "config.h"

#ifdef HAVE_OPENSSL
    #include <openssl/ssl.h>
    // Use OpenSSL
#endif

#ifdef DEBUG
    #define LOG(fmt, ...) fprintf(stderr, fmt, ##__VA_ARGS__)
#else
    #define LOG(fmt, ...)
#endif
\end{lstlisting}

\section{pkg-config Deep Dive}

pkg-config solves the "where are the libraries?" problem. Every library installs a .pc file describing itself.

\subsection{Understanding .pc Files}

\begin{lstlisting}
# /usr/lib/pkgconfig/openssl.pc
prefix=/usr
exec_prefix=${prefix}
libdir=${exec_prefix}/lib
includedir=${prefix}/include

Name: OpenSSL
Description: Secure Sockets Layer and cryptography libraries
Version: 1.1.1
Requires: libcrypto libssl
Libs: -L${libdir} -lssl -lcrypto
Libs.private: -ldl -lpthread
Cflags: -I${includedir}

# Query it:
pkg-config --cflags openssl
# Output: -I/usr/include

pkg-config --libs openssl
# Output: -L/usr/lib -lssl -lcrypto

pkg-config --libs --static openssl
# Output: -L/usr/lib -lssl -lcrypto -ldl -lpthread

pkg-config --modversion openssl
# Output: 1.1.1

pkg-config --exists openssl && echo "Found"
# Output: Found
\end{lstlisting}

\subsection{Using pkg-config in Makefiles}

\begin{lstlisting}
# Find packages
PKG_CONFIG ?= pkg-config

# Check if package exists
ifeq ($(shell $(PKG_CONFIG) --exists gtk+-3.0 && echo yes),yes)
    HAS_GTK = 1
    GTK_CFLAGS = $(shell $(PKG_CONFIG) --cflags gtk+-3.0)
    GTK_LIBS = $(shell $(PKG_CONFIG) --libs gtk+-3.0)
else
    HAS_GTK = 0
    GTK_CFLAGS =
    GTK_LIBS =
endif

# Use the flags
program: main.c
	$(CC) $(CFLAGS) $(GTK_CFLAGS) main.c -o program $(GTK_LIBS)

# Require minimum version
REQUIRED_VERSION = 3.20
ifeq ($(shell $(PKG_CONFIG) --atleast-version=$(REQUIRED_VERSION) gtk+-3.0 && echo yes),yes)
    $(info GTK+ version OK)
else
    $(error GTK+ >= $(REQUIRED_VERSION) required)
endif
\end{lstlisting}

\subsection{Creating Your Own .pc File}

When building a library, install a .pc file:

\begin{lstlisting}
# mylib.pc.in - Template
prefix=@prefix@
exec_prefix=@exec_prefix@
libdir=@libdir@
includedir=@includedir@

Name: MyLib
Description: My utility library
URL: https://example.com/mylib
Version: @VERSION@
Requires: zlib >= 1.2.0
Requires.private: openssl
Libs: -L${libdir} -lmylib
Libs.private: -lm
Cflags: -I${includedir}

# configure.ac substitutes @variables@
AC_CONFIG_FILES([mylib.pc])

# Makefile.am installs it
pkgconfigdir = $(libdir)/pkgconfig
pkgconfig_DATA = mylib.pc

# After installation, users can:
pkg-config --cflags --libs mylib
\end{lstlisting}

\section{Real Project Structure Explained}

Let's dissect a typical open-source C project:

\begin{lstlisting}
project/
+-- autogen.sh           # Bootstrap script (runs autotools)
+-- configure.ac         # Autoconf input
+-- Makefile.am          # Top-level Automake input
+-- config.h.in          # Config header template
+-- m4/                  # Custom autoconf macros
    +-- my_checks.m4
+-- src/
    +-- Makefile.am      # Source directory Automake input
    +-- main.c
    +-- utils.c
+-- include/
    +-- myproject.h.in   # Header template (version substitution)
+-- lib/                 # Library code
    +-- Makefile.am
    +-- libmylib.c
+-- tests/
    +-- Makefile.am
    +-- test_main.c
+-- docs/
    +-- Makefile.am
    +-- manual.md
+-- scripts/             # Helper scripts
    +-- build.sh         # Convenience build script
    +-- install-deps.sh  # Install dependencies
+-- .github/
    +-- workflows/
        +-- ci.yml       # GitHub Actions CI
+-- README.md
+-- LICENSE
+-- NEWS                 # Changelog (autotools convention)
+-- AUTHORS              # Contributors
+-- INSTALL              # Installation instructions

# Generated files (not in git):
+-- configure            # Generated by autoconf
+-- Makefile.in          # Generated by automake
+-- config.status        # Records configuration
+-- config.log           # Detailed test log
+-- Makefile             # Generated by configure
+-- config.h             # Generated by configure
+-- build/               # Out-of-tree build directory
+-- .deps/               # Dependency files
\end{lstlisting}

\subsection{The autogen.sh Bootstrap Script}

Many projects have autogen.sh to regenerate autotools files:

\begin{lstlisting}
#!/bin/sh
# autogen.sh - Regenerate autotools files

set -e  # Exit on error

echo "Bootstrapping build system..."

# Check for required tools
for tool in autoconf automake libtool; do
    if ! command -v $tool >/dev/null 2>&1; then
        echo "Error: $tool not found"
        exit 1
    fi
done

# Create m4 directory if needed
mkdir -p m4

# Copy auxiliary files
echo "Running libtoolize..."
libtoolize --copy --force

echo "Running aclocal..."
aclocal -I m4

echo "Running autoheader..."
autoheader

echo "Running automake..."
automake --add-missing --copy --foreign

echo "Running autoconf..."
autoconf

echo ""
echo "Bootstrap complete. Now run:"
echo "  ./configure"
echo "  make"
\end{lstlisting}

\subsection{The build.sh Convenience Script}

\begin{lstlisting}
#!/bin/bash
# build.sh - One-command build

set -e

# Configuration
PREFIX=${PREFIX:-/usr/local}
BUILD_TYPE=${BUILD_TYPE:-release}

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

info() {
    echo -e "${GREEN}[INFO]${NC} $*"
}

error() {
    echo -e "${RED}[ERROR]${NC} $*"
    exit 1
}

warn() {
    echo -e "${YELLOW}[WARN]${NC} $*"
}

# Check dependencies
info "Checking dependencies..."
for pkg in openssl zlib; do
    if ! pkg-config --exists $pkg; then
        error "Required package not found: $pkg"
    fi
done

# Clean if requested
if [ "$1" = "clean" ]; then
    info "Cleaning build artifacts..."
    make clean 2>/dev/null || true
    rm -rf build/
    info "Clean complete"
    exit 0
fi

# Bootstrap if needed
if [ ! -f configure ]; then
    info "Running autogen.sh..."
    ./autogen.sh
fi

# Create build directory
BUILD_DIR="build-$BUILD_TYPE"
mkdir -p "$BUILD_DIR"
cd "$BUILD_DIR"

# Configure
info "Configuring..."
CONFIG_FLAGS="--prefix=$PREFIX"

case $BUILD_TYPE in
    debug)
        CONFIG_FLAGS="$CONFIG_FLAGS --enable-debug"
        ;;
    release)
        CONFIG_FLAGS="$CONFIG_FLAGS --disable-debug"
        ;;
    *)
        error "Unknown build type: $BUILD_TYPE"
        ;;
esac

../configure $CONFIG_FLAGS

# Build
info "Building with $(nproc) parallel jobs..."
make -j$(nproc)

# Test
info "Running tests..."
make check

info "Build successful!"
echo ""
echo "To install:"
echo "  cd $BUILD_DIR && sudo make install"
\end{lstlisting}

\section{Conditional Compilation Patterns}

Real projects compile differently based on OS, architecture, and features.

\subsection{Platform Detection}

\begin{lstlisting}
# In configure.ac
AC_CANONICAL_HOST

case $host_os in
    linux*)
        AC_DEFINE([OS_LINUX], [1], [Linux OS])
        PLATFORM=linux
        ;;
    darwin*)
        AC_DEFINE([OS_MACOS], [1], [macOS])
        PLATFORM=macos
        ;;
    mingw* | msys*)
        AC_DEFINE([OS_WINDOWS], [1], [Windows])
        PLATFORM=windows
        ;;
    *)
        AC_MSG_ERROR([Unsupported OS: $host_os])
        ;;
esac

AC_SUBST([PLATFORM])

# In code (config.h defines these)
#ifdef OS_LINUX
    #include <linux/version.h>
    // Linux-specific code
#elif defined(OS_MACOS)
    #include <TargetConditionals.h>
    // macOS-specific code
#elif defined(OS_WINDOWS)
    #include <windows.h>
    // Windows-specific code
#endif
\end{lstlisting}

\subsection{Feature Detection}

\begin{lstlisting}
# configure.ac - Test if functions exist
AC_CHECK_FUNCS([clock_gettime])
AC_CHECK_FUNCS([pthread_setname_np])
AC_CHECK_FUNCS([strdup strndup])

# Check if struct has member
AC_CHECK_MEMBER([struct stat.st_mtim],
    [AC_DEFINE([HAVE_STAT_MTIM], [1], [struct stat has st_mtim])],
    [],
    [#include <sys/stat.h>])

# Test code compilation
AC_MSG_CHECKING([for C11 _Thread_local])
AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
    _Thread_local int x;
]], [[
    x = 42;
]])], [
    AC_MSG_RESULT([yes])
    AC_DEFINE([HAVE_THREAD_LOCAL], [1], [C11 thread_local available])
], [
    AC_MSG_RESULT([no])
])

# Usage in code
#ifdef HAVE_CLOCK_GETTIME
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
#else
    // Fallback implementation
    struct timeval tv;
    gettimeofday(&tv, NULL);
#endif
\end{lstlisting}

\subsection{Conditional Source Compilation}

\begin{lstlisting}
# Makefile.am - Conditional sources
myprogram_SOURCES = main.c utils.c

if HAVE_OPENSSL
myprogram_SOURCES += crypto.c
endif

if OS_LINUX
myprogram_SOURCES += linux_specific.c
endif

if OS_WINDOWS
myprogram_SOURCES += windows_specific.c
endif

# In configure.ac
AM_CONDITIONAL([HAVE_OPENSSL], [test "x$have_openssl" = "xyes"])
AM_CONDITIONAL([OS_LINUX], [test "x$PLATFORM" = "xlinux"])
AM_CONDITIONAL([OS_WINDOWS], [test "x$PLATFORM" = "xwindows"])
\end{lstlisting}

\section{Installation and DESTDIR}

Understanding how \texttt{make install} works is crucial.

\subsection{Standard Installation Directories}

\begin{lstlisting}
# configure --prefix=/usr/local (default)
# Creates these directories:

$prefix/bin              # Executables
$prefix/lib              # Libraries
$prefix/include          # Headers
$prefix/share            # Data files
$prefix/share/man        # Man pages
$prefix/share/doc        # Documentation
$prefix/etc              # Configuration
$prefix/var              # Variable data

# Real paths after ./configure --prefix=/usr/local:
# /usr/local/bin/myprogram
# /usr/local/lib/libmylib.so
# /usr/local/include/mylib.h
# /usr/local/share/myproject/data.txt
\end{lstlisting}

\subsection{DESTDIR for Package Building}

Package builders (RPM, DEB) need to install to a temporary directory:

\begin{lstlisting}
# Normal install:
./configure --prefix=/usr
make
sudo make install
# Installs to /usr/bin/program

# Package building:
./configure --prefix=/usr
make
make install DESTDIR=/tmp/package-root
# Installs to /tmp/package-root/usr/bin/program

# Then package manager creates .deb/.rpm from /tmp/package-root

# In Makefile:
install: all
	install -d $(DESTDIR)$(bindir)
	install -m 755 program $(DESTDIR)$(bindir)/
	install -d $(DESTDIR)$(libdir)
	install -m 644 libmylib.a $(DESTDIR)$(libdir)/
	install -d $(DESTDIR)$(includedir)
	install -m 644 mylib.h $(DESTDIR)$(includedir)/

# Variables:
# bindir = $(prefix)/bin
# libdir = $(prefix)/lib
# includedir = $(prefix)/include
# DESTDIR is prepended to everything
\end{lstlisting}

\subsection{Uninstall Target}

\begin{lstlisting}
# Makefile - Proper uninstall
uninstall:
	rm -f $(DESTDIR)$(bindir)/program
	rm -f $(DESTDIR)$(libdir)/libmylib.a
	rm -f $(DESTDIR)$(includedir)/mylib.h
	rm -rf $(DESTDIR)$(datadir)/myproject

# Automake generates this automatically from install rules
\end{lstlisting}

\section{Embedded Version Information}

Real projects embed version info in binaries.

\begin{lstlisting}
# configure.ac
AC_INIT([myproject], [1.2.3])
AC_SUBST([VERSION], [1.2.3])

# Generate version header
AC_CONFIG_FILES([include/version.h])

# version.h.in
#ifndef VERSION_H
#define VERSION_H

#define PROJECT_VERSION "@VERSION@"
#define VERSION_MAJOR @VERSION_MAJOR@
#define VERSION_MINOR @VERSION_MINOR@
#define VERSION_PATCH @VERSION_PATCH@

// Git commit (if building from git)
#define GIT_COMMIT "@GIT_COMMIT@"

#endif

# Makefile.am - Extract version components
VERSION_MAJOR = $(shell echo $(VERSION) | cut -d. -f1)
VERSION_MINOR = $(shell echo $(VERSION) | cut -d. -f2)
VERSION_PATCH = $(shell echo $(VERSION) | cut -d. -f3)

# Get git commit
GIT_COMMIT = $(shell git rev-parse --short HEAD 2>/dev/null || echo unknown)

# Usage in code
#include "version.h"

void print_version(void) {
    printf("%s version %s (git: %s)\n",
           PROJECT_NAME, PROJECT_VERSION, GIT_COMMIT);
}
\end{lstlisting}

\section{Build Variants}

Real projects support multiple build configurations simultaneously.

\begin{lstlisting}
# Build multiple variants
./configure --prefix=/usr --enable-debug
make
mv src/program src/program-debug

make clean
./configure --prefix=/usr --disable-debug --enable-optimizations
make
mv src/program src/program-release

# Better: use build directories
mkdir build-debug
cd build-debug
../configure --enable-debug
make

cd ..
mkdir build-release
cd build-release
../configure --disable-debug
make

# Now you have both:
# build-debug/src/program
# build-release/src/program
\end{lstlisting}

\section{Common Real-World Patterns}

\subsection{Checking for Optional Features}

\begin{lstlisting}
# Check for readline (for interactive programs)
AC_CHECK_HEADERS([readline/readline.h])
AC_CHECK_LIB([readline], [readline], [
    HAVE_READLINE=yes
    READLINE_LIBS=-lreadline
], [
    HAVE_READLINE=no
    READLINE_LIBS=
])
AC_SUBST([READLINE_LIBS])

# Use in code
#ifdef HAVE_READLINE_READLINE_H
    #include <readline/readline.h>
    char* input = readline("prompt> ");
#else
    char input[256];
    printf("prompt> ");
    fgets(input, sizeof(input), stdin);
#endif
\end{lstlisting}

\subsection{Custom Configure Options}

\begin{lstlisting}
# Add custom configuration options
AC_ARG_ENABLE([profiling],
    AS_HELP_STRING([--enable-profiling], [Enable profiling support]),
    [enable_profiling=$enableval],
    [enable_profiling=no])

AC_ARG_WITH([custom-allocator],
    AS_HELP_STRING([--with-custom-allocator], [Use custom allocator]),
    [use_custom_allocator=yes],
    [use_custom_allocator=no])

AC_ARG_VAR([MAX_THREADS], [Maximum number of threads (default: 16)])
if test -z "$MAX_THREADS"; then
    MAX_THREADS=16
fi

AC_DEFINE_UNQUOTED([MAX_THREADS], [$MAX_THREADS], [Maximum threads])

# Usage:
./configure --enable-profiling --with-custom-allocator MAX_THREADS=32
\end{lstlisting}

\section{Real Project Examples}

Let me show you exactly how different popular C projects handle building.

\subsection{Example 1: Redis (Simple Makefile)}

Redis deliberately avoids autotools for simplicity:

\begin{lstlisting}
# Clone Redis
git clone https://github.com/redis/redis.git
cd redis

# No configure script! Just:
make

# Why? Redis's Makefile is smart:
# redis/Makefile

# Detect OS
uname_S := $(shell uname -s)

# Platform-specific settings
ifeq ($(uname_S),Linux)
    CFLAGS += -DHAVE_EPOLL
    LDFLAGS += -ldl -pthread
endif
ifeq ($(uname_S),Darwin)
    CFLAGS += -DHAVE_KQUEUE
endif
ifeq ($(uname_S),FreeBSD)
    CFLAGS += -DHAVE_KQUEUE
    LDFLAGS += -lpthread
endif

# Auto-detect dependencies
ifeq ($(shell pkg-config --exists openssl && echo yes),yes)
    CFLAGS += $(shell pkg-config --cflags openssl)
    LDFLAGS += $(shell pkg-config --libs openssl)
endif

# Build
redis-server: redis.o networking.o ...
	$(CC) -o $@ $^ $(LDFLAGS)

# Simple and works!
# Trade-off: Less portable than autotools
# Works for Redis because they control dependencies
\end{lstlisting}

\subsection{Example 2: SQLite (Amalgamation Build)}

SQLite uses a clever trick—ship all code in ONE file:

\begin{lstlisting}
# Download SQLite
wget https://sqlite.org/2023/sqlite-amalgamation-3400000.zip
unzip sqlite-amalgamation-3400000.zip
cd sqlite-amalgamation-3400000

# Contents:
ls
sqlite3.c    # ALL SQLite code in one file (240,000 lines!)
sqlite3.h    # Public header
shell.c      # Command-line tool

# Build is trivial:
gcc -O2 -o sqlite3 shell.c sqlite3.c -lpthread -ldl

# Why this works:
# - No build system needed
# - No dependencies
# - Compiles everywhere
# - Users can't mess up the build

# The "amalgamation" is generated from 100+ source files:
# (developers work on separate files, release as one file)
\end{lstlisting}

\subsection{Example 3: Git (Autoconf Optional)}

Git supports both autotools AND manual configuration:

\begin{lstlisting}
# Clone Git
git clone https://github.com/git/git.git
cd git

# Method 1: Manual configuration
make configure
./configure
make

# Method 2: Direct make (tries to auto-detect)
make

# How? Git's Makefile detects features:
# Makefile
ifeq ($(shell echo '\#include <openssl/ssl.h>' | gcc -E - 2>/dev/null | grep -c ssl.h),1)
    OPENSSL_AVAIL = YesPlease
endif

ifdef OPENSSL_AVAIL
    BASIC_CFLAGS += -DHAVE_OPENSSL
    EXTLIBS += -lssl -lcrypto
endif

# Clever: Works without configure, but configure available if needed
\end{lstlisting}

\subsection{Example 4: nginx (Hand-Written Configure)}

nginx has a custom configure script (NOT autotools):

\begin{lstlisting}
# Clone nginx
git clone https://github.com/nginx/nginx.git
cd nginx

# Configure with custom script:
./auto/configure \
    --prefix=/usr/local/nginx \
    --with-http_ssl_module \
    --with-pcre

# What's different from autotools?
# auto/configure is a HAND-WRITTEN shell script
# Specifically tailored for nginx
# Simpler than autotools but less portable

# Why nginx does this:
# - Full control over build process
# - Optimized for web server needs
# - Handles module system elegantly
# - Simpler for nginx developers

# Inside auto/configure:
#!/bin/sh

# Detect compiler
if [ -n "$CC" ]; then
    echo "using $CC compiler"
else
    if [ -x /usr/bin/gcc ]; then
        CC=gcc
    elif [ -x /usr/bin/cc ]; then
        CC=cc
    fi
fi

# Check for OpenSSL
if [ -f /usr/include/openssl/ssl.h ]; then
    OPENSSL_FOUND=YES
    OPENSSL_CFLAGS="-I/usr/include"
    OPENSSL_LIBS="-lssl -lcrypto"
fi

# Generate Makefile
cat > Makefile << END
CC = $CC
CFLAGS = $CFLAGS $OPENSSL_CFLAGS
LIBS = $LIBS $OPENSSL_LIBS

nginx: ngx_main.o ngx_event.o ...
	\$(CC) -o nginx \$^ \$(LIBS)
END
\end{lstlisting}

\section{The Packaging Perspective}

When distributions (Debian, Fedora, Arch) package your software, they need:

\subsection{Debian Package Build}

\begin{lstlisting}
# How Debian builds curl package:

# 1. Download source
wget https://curl.se/download/curl-7.88.0.tar.gz
tar xzf curl-7.88.0.tar.gz
cd curl-7.88.0

# 2. Configure for Debian's standards
./configure \
    --prefix=/usr \
    --sysconfdir=/etc \
    --localstatedir=/var \
    --mandir=/usr/share/man \
    --enable-shared \
    --disable-static \
    --with-openssl \
    --with-ca-bundle=/etc/ssl/certs/ca-certificates.crt

# 3. Build
make -j$(nproc)

# 4. Install to temporary directory
make install DESTDIR=$PWD/debian/tmp

# 5. Create .deb package
dpkg-deb --build debian/tmp curl_7.88.0-1_amd64.deb

# Now users can:
apt install ./curl_7.88.0-1_amd64.deb
\end{lstlisting}

\subsection{Why DESTDIR Matters}

\begin{lstlisting}
# Without DESTDIR (WRONG for packaging):
./configure --prefix=/usr
make
make install
# Installs directly to /usr/bin/curl
# Can't build packages this way!

# With DESTDIR (RIGHT for packaging):
./configure --prefix=/usr
make
make install DESTDIR=/tmp/package-root
# Installs to /tmp/package-root/usr/bin/curl
# Package manager packages /tmp/package-root/*

# In Makefile, this works because:
install: all
	install -d $(DESTDIR)$(bindir)
	install -m 755 curl $(DESTDIR)$(bindir)/

# bindir = /usr/bin
# DESTDIR = /tmp/package-root
# Full path: /tmp/package-root/usr/bin/curl
\end{lstlisting}

\section{Troubleshooting Real Build Problems}

\subsection{Problem 1: "configure: error: OpenSSL not found"}

\begin{lstlisting}
# Error during configure:
./configure
checking for openssl/ssl.h... no
configure: error: OpenSSL development files not found

# Why? Missing development headers
# Solution depends on distro:

# Ubuntu/Debian:
sudo apt-get install libssl-dev

# Fedora/RHEL:
sudo dnf install openssl-devel

# macOS:
brew install openssl
# macOS keeps OpenSSL in non-standard location:
./configure --with-ssl=$(brew --prefix openssl)

# Now configure finds it:
checking for openssl/ssl.h... yes
checking for SSL_connect in -lssl... yes
\end{lstlisting}

\subsection{Problem 2: "undefined reference to `pthread\_create'"}

\begin{lstlisting}
# Error during linking:
gcc -o program main.o -lssl -lcrypto
main.o: undefined reference to `pthread_create'

# Why? Missing -lpthread

# Solution: Add to LDFLAGS
./configure LDFLAGS="-lpthread"

# Or in Makefile:
LDFLAGS += -lpthread
\end{lstlisting}

\subsection{Problem 3: "cannot find -lz"}

\begin{lstlisting}
# Error:
/usr/bin/ld: cannot find -lz

# Why? libz.so not in standard path

# Find it:
find /usr -name "libz.so*"
# Found: /usr/local/lib/libz.so

# Solution 1: Tell linker where to look
./configure LDFLAGS="-L/usr/local/lib"

# Solution 2: Add to library path
export LD_LIBRARY_PATH=/usr/local/lib
./configure

# Solution 3: Install system package
sudo apt-get install zlib1g-dev
\end{lstlisting}

\section{Summary}

Build systems are crucial for productive C development. Now you understand:

\begin{itemize}
    \item \textbf{Why configure exists}: Solves Unix portability nightmare
    \item \textbf{What configure does}: Tests system, generates Makefiles
    \item \textbf{configure.ac -> configure}: autoconf generates 40K line shell script
    \item \textbf{Makefile.in -> Makefile}: configure fills in variables
    \item \textbf{config.h}: Stores feature detection results
    \item \textbf{Make}: Tracks dependencies, rebuilds what changed
    \item \textbf{pkg-config}: Finds libraries via .pc files
    \item \textbf{DESTDIR}: Enables package building
    \item \textbf{Installation paths}: prefix, bindir, libdir, etc.
\end{itemize}

\textbf{The complete picture}:

\begin{verbatim}
DEVELOPER WORKFLOW:
1. Write configure.ac (3,000 lines of M4 macros)
2. Write Makefile.am (high-level build description)
3. Run autoconf -> generates configure (40,000 lines of shell)
4. Run automake -> generates Makefile.in (template)
5. Commit configure to git (users don't need autotools)
6. Create tarball: tar czf project-1.0.tar.gz ...

USER WORKFLOW:
1. Download tarball
2. tar xzf project-1.0.tar.gz
3. cd project-1.0
4. ./configure (tests system, generates Makefile)
5. make (compiles code)
6. make check (runs tests)
7. sudo make install (copies to /usr/local)

PACKAGER WORKFLOW (Debian/Fedora):
1. ./configure --prefix=/usr
2. make
3. make install DESTDIR=/tmp/staging
4. Package /tmp/staging/* into .deb/.rpm
5. Users install via: apt/dnf install package
\end{verbatim}

\textbf{Why each step matters}:

\begin{itemize}
    \item \textbf{configure}: Can't hardcode paths—every system is different
    \item \textbf{config.h}: Runtime checks for missing functions
    \item \textbf{Makefile generation}: Different flags per system
    \item \textbf{pkg-config}: Libraries install in different locations
    \item \textbf{DESTDIR}: Can't install to /usr during package build
    \item \textbf{Dependency tracking}: Don't recompile unchanged files
\end{itemize}

\textbf{Alternative approaches}:

\begin{itemize}
    \item \textbf{Simple Makefile} (Redis): If you control dependencies
    \item \textbf{Amalgamation} (SQLite): Ship as single .c file
    \item \textbf{Custom configure} (nginx): Hand-written for your needs
    \item \textbf{CMake/Meson}: Modern alternatives to autotools
\end{itemize}

\textbf{When you see confusing builds now}:

\begin{lstlisting}
# curl
./buildconf     # Generate configure (developer only)
./configure     # Test system
make            # Build
make install    # Install

# Why buildconf? Generates configure from configure.ac
# Why configure? Detects OpenSSL, zlib, platform differences
# Why make? Compiles with detected settings
\end{lstlisting}

\textbf{Key insight}: Real C projects aren't complex to be difficult—they're complex because they solve REAL problems (portability across dozens of Unix variants, optional dependencies, graceful degradation when features missing).

Every confusing part has a reason:
\begin{itemize}
    \item configure.ac exists because hardcoded paths break
    \item config.h exists because functions differ per system
    \item Makefile.in is a template because flags vary per platform
    \item pkg-config exists because library locations vary
    \item DESTDIR exists because packagers need staging directories
\end{itemize}

Now when you clone a C project, you understand the build system isn't arbitrary complexity—it's battle-tested solutions to decades of portability problems!
