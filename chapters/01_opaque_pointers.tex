\chapter{The Opaque Pointer Pattern}

\section{What Is It?}

The opaque pointer pattern (also called "pimpl" or "handle" pattern) is one of the most important idioms in professional C code. It's a way to hide the internal details of a data structure from users of your code. Think of it as the "none of your business" pattern, but polite and professional.

\subsection*{The Locked Box Analogy}

Think of it like a locked box with a claim ticket. Imagine you go to a coat check at a fancy restaurant:

\begin{enumerate}
    \item You hand your coat to the attendant
    \item The attendant puts it in a locked closet (you can't see inside)
    \item You get a ticket with a number on it (the "pointer")
    \item Later, you give back the ticket and get your coat
    \item You never saw where your coat was stored or how the closet is organized
    \item The attendant can reorganize the closet however they want---you don't care, you just want your coat back
\end{enumerate}

That's exactly how opaque pointers work! The user gets a "ticket" (pointer) that represents their data, but they can't see or access the actual storage. They must ask the library functions (the "attendants") to do things with their data.

\subsection*{Why This Matters in the Real World}

Here's what the textbooks don't tell you: this pattern is the foundation of almost every stable C API in existence. Let me give you concrete examples:

\begin{itemize}
    \item \textbf{OpenSSL} (security library): Has used this for 20+ years. They've added new features, fixed bugs, and optimized internals---all without breaking existing programs
    \item \textbf{Linux kernel}: Maintains stable interfaces so device drivers written 10 years ago still work
    \item \textbf{GTK+} (graphical toolkit): Can evolve and improve without forcing every app to recompile
    \item \textbf{SQLite} (database): Can change its internal storage format without breaking apps
\end{itemize}

It's basically the "trust me, I know what I'm doing" pattern, except done properly. You're saying to users: "You don't need to know how this works internally. Just trust that when you call my functions, I'll do the right thing." (And if they don't trust you, well, they can go write their own library. Good luck with that.)

\section{Why Use It? The Real Reasons}

\begin{enumerate}
    \item \textbf{ABI Stability}: Change internals without recompiling user code
    \item \textbf{Information Hiding}: Users can't accidentally break invariants
    \item \textbf{Reduced Coupling}: Implementation can change completely
    \item \textbf{Faster Compilation}: Users don't include implementation headers
    \item \textbf{Trade Secret Protection}: Hide proprietary algorithms
    \item \textbf{Multiple Implementations}: Same API, different backends
    \item \textbf{Stable Symbol Table}: Fewer exported symbols in shared libraries
\end{enumerate}

Let me explain the ABI stability point because it's crucial: When you ship a shared library (\texttt{.so} or \texttt{.dll}), your users compile against your headers. If you expose struct internals, adding a single field breaks binary compatibility. Every user must recompile. And they will be... unhappy. (That's putting it mildly. In reality, they'll write angry emails, create bug reports with CAPS LOCK, and possibly send you passive-aggressive tweets at 2 AM.) With opaque pointers, you can add, remove, or reorder fields freely. This is why every long-lived C library uses this pattern---survival instinct.

\section{The Basic Pattern}

\subsection{In the Header File (mylib.h)}

\begin{lstlisting}
#ifndef MYLIB_H
#define MYLIB_H

// Forward declaration - users see this
// They know the type exists but not what's inside
typedef struct MyObject MyObject;

// Constructor - returns pointer to opaque type
MyObject* myobject_create(void);

// Operations - all take opaque pointer
void myobject_do_something(MyObject* obj);
int myobject_get_value(const MyObject* obj);
void myobject_set_name(MyObject* obj, const char* name);

// Destructor - frees opaque object
void myobject_destroy(MyObject* obj);

#endif /* MYLIB_H */
\end{lstlisting}

\subsection*{Understanding This Header - Line by Line}

Let's break down what's happening here in plain English:

\textbf{Line: \texttt{typedef struct MyObject MyObject;}}

This is the magic line! This is called a "forward declaration" or "incomplete type." Think of it like this:

\begin{itemize}
    \item You're telling the compiler: "Hey, there's a thing called MyObject. I'm not telling you what's inside it, but it exists somewhere. Trust me on this."
    \item It's like saying "There's a person named Bob" without describing what Bob looks like, what Bob does for a living, or whether Bob is even human
    \item The compiler accepts this and lets users use \texttt{MyObject*} (pointer to MyObject)
    \item But the compiler won't let users do \texttt{sizeof(MyObject)} or \texttt{obj.value} because it doesn't know the contents (and that's the whole point---we're gatekeeping our struct like it's an exclusive nightclub)
\end{itemize}

\textbf{Why this works:} In C, you can have a pointer to something without knowing its size! A pointer is just a memory address (8 bytes on 64-bit systems, 4 bytes on 32-bit). The compiler doesn't need to know how big MyObject is to pass around its address.

\textbf{Function: \texttt{MyObject* myobject\_create(void);}}

This is the "constructor"---the function that creates new objects. Think of it as a factory:

\begin{itemize}
    \item User calls this function
    \item Function allocates memory (using malloc internally---users don't see this)
    \item Function returns a pointer---the "claim ticket" to the object
    \item User stores this pointer but can't peek inside
\end{itemize}

Real-world analogy: Like ordering food at a restaurant. You place an order, they give you a number, you wait. You don't go into the kitchen to cook it yourself!

\textbf{Function: \texttt{void myobject\_do\_something(MyObject* obj);}}

This is an "operation" function. The user:

\begin{itemize}
    \item Passes in their claim ticket (the pointer)
    \item The function accesses the real object
    \item Does something with it
    \item Returns (possibly with a result)
\end{itemize}

The user never touches the object directly. It's like asking a librarian to get a book from the restricted section---you hand them your library card, they get the book, they do something with it. You never enter the restricted area.

\textbf{Function: \texttt{void myobject\_destroy(MyObject* obj);}}

This is the "destructor"---cleanup function. Important points:

\begin{itemize}
    \item User MUST call this when done
    \item Function frees all memory
    \item After calling this, the pointer is invalid (ticket is voided)
    \item If user doesn't call this---memory leak! (Like never picking up your coat from coat check---it sits there forever)
\end{itemize}

\begin{notebox}
\textbf{About \texttt{const}:} Notice the \texttt{const} on \texttt{myobject\_get\_value}. This tells the compiler: "This function won't modify the object, it only reads from it." It's like the difference between a librarian who lets you \textit{read} a book vs one who lets you \textit{edit} it. Even though users can't see inside, you can still enforce const-correctness in your API! This prevents users from accidentally modifying objects when they just wanted to read them.
\end{notebox}

\subsection{In the Implementation File (mylib.c)}

\begin{lstlisting}
#include "mylib.h"
#include <stdlib.h>
#include <string.h>

// The actual definition - users NEVER see this
// You can change this freely without breaking user code
struct MyObject {
    int value;
    char* name;
    size_t ref_count;  // For reference counting
    void* internal_state;  // Internal implementation details
    // Add more fields anytime - ABI stays stable!
};

MyObject* myobject_create(void) {
    MyObject* obj = malloc(sizeof(MyObject));
    if (obj) {
        obj->value = 0;
        obj->name = NULL;
        obj->ref_count = 1;
        obj->internal_state = NULL;
    }
    return obj;
}

void myobject_do_something(MyObject* obj) {
    if (!obj) return;  // Defensive programming

    obj->value++;
    // Users can't accidentally bypass this logic
    // and corrupt obj->value
}

int myobject_get_value(const MyObject* obj) {
    return obj ? obj->value : -1;
}

void myobject_set_name(MyObject* obj, const char* name) {
    if (!obj) return;

    // Free old name
    free(obj->name);

    // Duplicate new name
    obj->name = name ? strdup(name) : NULL;
}

void myobject_destroy(MyObject* obj) {
    if (obj) {
        free(obj->name);
        free(obj->internal_state);
        free(obj);
    }
}
\end{lstlisting}

\subsection*{Understanding the Implementation - The Secret Recipe}

This is where the magic happens! This file is like the restaurant's kitchen---customers (users) never see it, but this is where the real work is done.

\textbf{The Full Struct Definition}

\begin{lstlisting}
struct MyObject {
    int value;
    char* name;
    size_t ref_count;
    void* internal_state;
};
\end{lstlisting}

This is the COMPLETE definition. Notice:

\begin{itemize}
    \item This appears ONLY in the .c file, never in the .h file
    \item Users who include your library never see this
    \item You can add fields, remove fields, reorder fields---users won't notice
    \item It's like the secret recipe---you know what's in it, customers just taste the result
\end{itemize}

\textbf{Why can you change it freely?} Because when users compile their code, they only see the header file. They never compile this .c file! You compile the .c file into a library (.so or .dll), and users link against that library. As long as function names and parameters don't change, the internals can be completely different.

\textbf{The Create Function - Step by Step}

\begin{lstlisting}
MyObject* myobject_create(void) {
    MyObject* obj = malloc(sizeof(MyObject));  // [1]
    if (obj) {                                  // [2]
        obj->value = 0;                         // [3]
        obj->name = NULL;
        obj->ref_count = 1;
        obj->internal_state = NULL;
    }
    return obj;                                 // [4]
}
\end{lstlisting}

Let's walk through this like we're explaining it to a 10-year-old:

\begin{enumerate}
    \item \textbf{[1] Allocate memory}: \texttt{malloc(sizeof(MyObject))}
    \begin{itemize}
        \item Ask the operating system: "Hey, can I have enough memory to store a MyObject?"
        \item OS responds: "Sure, here's the address: 0x5589a4f0"
        \item malloc returns this address (the pointer)
        \item Think of it like renting a storage unit---you get the unit number (address)
    \end{itemize}

    \item \textbf{[2] Check if allocation succeeded}: \texttt{if (obj)}
    \begin{itemize}
        \item Sometimes the OS says "Sorry, I'm out of memory!" and returns NULL
        \item We check if we actually got memory before using it
        \item Like checking if the ATM actually gave you money before walking away
        \item If malloc failed, we skip initialization and return NULL to user
    \end{itemize}

    \item \textbf{[3] Initialize the fields}: Set everything to safe defaults
    \begin{itemize}
        \item \texttt{obj->value = 0}: Start the value at zero (like resetting a counter)
        \item \texttt{obj->name = NULL}: No name yet (empty string would be \texttt{""})
        \item \texttt{obj->ref\_count = 1}: Someone is using this (the creator)
        \item \texttt{obj->internal\_state = NULL}: No extra state yet
        \item This is like unboxing a new phone---it comes with default settings
    \end{itemize}

    \item \textbf{[4] Return the pointer}: Give the "claim ticket" to the user
    \begin{itemize}
        \item User gets the address: 0x5589a4f0
        \item They can't see what's at that address, but they can pass it back to us
        \item Like getting a valet ticket---you don't know where they parked your car, but you can get it back with the ticket
    \end{itemize}
\end{enumerate}

\textbf{The Do Something Function - Controlled Access}

\begin{lstlisting}
void myobject_do_something(MyObject* obj) {
    if (!obj) return;  // Safety check
    obj->value++;      // Increment value
}
\end{lstlisting}

This demonstrates a key principle: \textbf{controlled modification}

\begin{itemize}
    \item User can't do \texttt{obj->value++} directly (won't compile!)
    \item User MUST call \texttt{myobject\_do\_something(obj)}
    \item We can add validation, logging, locking---whatever we want
    \item User just sees: "I called a function, something happened"
\end{itemize}

Real-world example: Imagine a bank account. You can't directly edit the balance in the bank's database. You call \texttt{withdraw()} or \texttt{deposit()}, and the bank updates it for you (with proper checks!). This is the same concept.

\textbf{The Get Value Function - Safe Reading}

\begin{lstlisting}
int myobject_get_value(const MyObject* obj) {
    return obj ? obj->value : -1;
}
\end{lstlisting}

This is a "getter" function. Breaking it down:

\begin{itemize}
    \item \texttt{const MyObject* obj}: The \texttt{const} means "I promise not to modify this object"
    \item \texttt{obj ? obj->value : -1}: This is a ternary operator (shorthand if/else)
    \begin{itemize}
        \item If obj is not NULL: return obj->value
        \item If obj is NULL: return -1 (error code)
    \end{itemize}
    \item Users get the value without touching the internals
\end{itemize}

It's like asking a store clerk "How much does this cost?" They look at the price tag (which you can't see) and tell you. You don't need to see the tag directly.

\textbf{The Destroy Function - Cleanup}

\begin{lstlisting}
void myobject_destroy(MyObject* obj) {
    if (obj) {
        free(obj->name);           // [1] Free the name string
        free(obj->internal_state); // [2] Free internal data
        free(obj);                 // [3] Free the object itself
    }
}
\end{lstlisting}

Critical cleanup sequence:

\begin{enumerate}
    \item \textbf{Free owned resources first}: Free \texttt{name} and \texttt{internal\_state}
    \begin{itemize}
        \item These were allocated separately (by strdup or other allocations)
        \item Must be freed before freeing the object
        \item Like emptying a box before throwing the box away
    \end{itemize}

    \item \textbf{Free the object last}: \texttt{free(obj)}
    \begin{itemize}
        \item This releases the memory we got from malloc
        \item After this, the pointer is invalid---it's a "dangling pointer"
        \item Using it after free = undefined behavior (crash, corruption, or worse)
        \item Like burning your valet ticket---you can't use it anymore
    \end{itemize}
\end{enumerate}

\begin{warningbox}
\textbf{Common Mistake:} New programmers often do:
\begin{lstlisting}
free(obj);           // BUG! Free the object first
free(obj->name);     // CRASH! obj->name is invalid now
\end{lstlisting}

You must free in reverse order: free the things inside, THEN free the container. It's like unpacking boxes---take items out first, then throw away the box.
\end{warningbox}

\section{What Actually Happens in Memory}

Here's what most books won't tell you: Let's examine the memory layout and how this works at the binary level.

\begin{lstlisting}
// When user code calls:
MyObject* obj = myobject_create();

// What actually happens:
// 1. malloc() allocates memory on the heap
// 2. The address is returned as a void-like pointer
// 3. User only knows it's a "MyObject*" - an address
// 4. User has NO IDEA how much memory is allocated
// 5. sizeof(MyObject) won't compile in user code!

// In memory (64-bit system):
// Address      Content
// 0x5589a4f0:  0x0000002A          // obj->value = 42
// 0x5589a4f4:  (padding)
// 0x5589a4f8:  0x5589b120          // obj->name pointer
// 0x5589a500:  0x00000001          // obj->ref_count
// 0x5589a508:  0x00000000          // obj->internal_state
// 0x5589a510:  (next allocation)

// User code only has: 0x5589a4f0 (the pointer)
// User cannot do: obj->value  (won't compile!)
// User cannot do: sizeof(*obj)  (won't compile!)
// User MUST use: myobject_get_value(obj)
\end{lstlisting}

\subsection*{Visualizing Memory - The Storage Unit Analogy}

Think of computer memory like a massive storage facility with millions of units:

\begin{itemize}
    \item Each unit has an address (like "Unit 0x5589a4f0")
    \item When you call malloc, you rent some units
    \item The pointer is the unit number---that's ALL you get
    \item You don't know what's in the units, you can't open them yourself
    \item You have to ask the storage facility staff (the library functions) to get things in/out
\end{itemize}

\textbf{What's actually stored?} Let's break down the memory layout:

\begin{enumerate}
    \item \textbf{0x5589a4f0: Value (4 bytes)}: The integer value (currently 42 or 0x2A in hex)
    \begin{itemize}
        \item Takes up 4 bytes because \texttt{int} is typically 4 bytes
        \item Stored in binary: 00000000 00000000 00000000 00101010
    \end{itemize}

    \item \textbf{0x5589a4f4: Padding (4 bytes)}: Empty space!
    \begin{itemize}
        \item Why? Because the next field is a pointer (8 bytes on 64-bit systems)
        \item Pointers must be aligned to 8-byte boundaries for performance
        \item CPU reads memory faster when data is aligned
        \item It's like leaving a gap on a shelf so the next item fits perfectly
    \end{itemize}

    \item \textbf{0x5589a4f8: Name pointer (8 bytes)}: Address pointing to the string
    \begin{itemize}
        \item Not the string itself! Just the address where the string is stored
        \item The string "hello" might be at address 0x5589b120
        \item If name is NULL, this would be 0x0000000000000000
        \item Like storing a forwarding address instead of the actual item
    \end{itemize}

    \item \textbf{0x5589a500: Reference count (8 bytes)}: How many owners
    \begin{itemize}
        \item \texttt{size\_t} is 8 bytes on 64-bit systems
        \item Tracks how many references point to this object
        \item Used for memory management (more on this later)
    \end{itemize}

    \item \textbf{0x5589a508: Internal state pointer (8 bytes)}: Extra data
    \begin{itemize}
        \item Another pointer to additional data
        \item Currently NULL (all zeros)
        \item Allows for future expansion without changing the struct
    \end{itemize}
\end{enumerate}

\textbf{Total size}: 4 + 4 + 8 + 8 + 8 = 32 bytes for one MyObject!

\textbf{What the user has:} Just the number 0x5589a4f0. That's it! They can't:
\begin{itemize}
    \item Read \texttt{obj->value} (compiler error: incomplete type)
    \item Write \texttt{obj->name = "test"} (compiler error: incomplete type)
    \item Call \texttt{sizeof(*obj)} (compiler error: incomplete type)
    \item Allocate on stack: \texttt{MyObject obj;} (compiler error: incomplete type)
\end{itemize}

They can ONLY:
\begin{itemize}
    \item Store the pointer: \texttt{MyObject* ptr = obj;}
    \item Pass it to functions: \texttt{myobject\_do\_something(obj);}
    \item Compare it: \texttt{if (obj1 == obj2)}
    \item Check for NULL: \texttt{if (obj != NULL)}
\end{itemize}

\begin{tipbox}
\textbf{Pro tip:} The incomplete type prevents users from allocating objects on the stack. This gives you control: all objects must go through your allocator, which means you can track them, pool them, or implement custom memory management.

Think of it like this: If users could create objects themselves (\texttt{MyObject obj;}), they could create them on the stack (temporary storage). When the function returns, that memory disappears---poof! Your library wouldn't know about it, couldn't track it, and couldn't clean it up properly.

By forcing users to call \texttt{myobject\_create()}, YOU control where the memory comes from. You could:
\begin{itemize}
    \item Allocate from a custom pool (faster than malloc)
    \item Keep a list of all live objects (useful for debugging)
    \item Add guards around the memory to detect corruption
    \item Use reference counting to prevent leaks
\end{itemize}

It's like being the bouncer at an exclusive club---nobody gets in without your permission, and you know exactly who's inside at all times.
\end{tipbox}

\section{Real-World Examples from Production Code}

Let's see how real, battle-tested projects use opaque pointers. These aren't toy examples---these are patterns from software running on millions of machines worldwide.

\subsection{Example 1: FILE* in the Standard Library}

This is exactly how \texttt{FILE*} works! You've been using opaque pointers all along.

\begin{lstlisting}
// In stdio.h (simplified):
typedef struct _IO_FILE FILE;  // Opaque!

FILE* fopen(const char* path, const char* mode);
int fclose(FILE* stream);

// You use it like this:
FILE* f = fopen("data.txt", "r");
if (f) {
    // You have NO IDEA what's in FILE
    // Is there a buffer? Buffer size? File descriptor?
    // Position? Error flags? You don't know and don't need to!

    fread(buffer, 1, size, f);  // Just works
    fclose(f);
}

// The actual FILE structure (glibc implementation):
struct _IO_FILE {
    int _flags;
    char* _IO_read_ptr;
    char* _IO_read_end;
    char* _IO_read_base;
    char* _IO_write_base;
    char* _IO_write_ptr;
    char* _IO_write_end;
    char* _IO_buf_base;
    char* _IO_buf_end;
    // ... many more fields

    struct _IO_FILE* _chain;
    int _fileno;
    // ... even more fields
};

// This structure has changed over 30 years of glibc evolution
// Your code from 1995? Still compiles and runs!
// That's the power of opaque pointers
// (Unlike your Pentium from 1995, which definitely does NOT still run)
\end{lstlisting}

\subsection{Example 2: Redis - String Objects (SDS)}

\textbf{What is Redis?} An in-memory data store used by Twitter, GitHub, Stack Overflow, and millions of other sites. It's famous for being blazingly fast and rock-solid.

\textbf{The Pattern:} Redis uses opaque pointers for its "Simple Dynamic String" (SDS) type.

\begin{lstlisting}
// In Redis header (sds.h) - What users see:
typedef char *sds;  // Opaque! Looks like char* but isn't

sds sdsnew(const char *init);           // Create new string
void sdsfree(sds s);                     // Free string
sds sdscat(sds s, const char *t);       // Concatenate
size_t sdslen(const sds s);             // Get length
\end{lstlisting}

\textbf{The Secret (sds.c):} The actual structure is HIDDEN BEFORE the pointer!

\begin{lstlisting}
// The real structure (users never see this):
struct sdshdr {
    unsigned int len;        // Current string length
    unsigned int free;       // Unused bytes in buffer
    char buf[];             // Flexible array member
};

// The trick: 'sds' points to buf, not to the struct!
// Memory layout:
// [len][free][b][u][f][f][e][r][\0]
//             ^
//             sds points here!

sds sdsnew(const char *init) {
    size_t initlen = strlen(init);
    // Allocate struct + buffer space
    struct sdshdr *sh = malloc(sizeof(struct sdshdr) + initlen + 1);

    sh->len = initlen;
    sh->free = 0;
    memcpy(sh->buf, init, initlen + 1);

    return sh->buf;  // Return pointer to buffer, not struct!
}

size_t sdslen(const sds s) {
    // Get the struct by backing up from the pointer!
    struct sdshdr *sh = (void*)(s - sizeof(struct sdshdr));
    return sh->len;
}
\end{lstlisting}

\textbf{Why This Is Brilliant:}

\begin{enumerate}
    \item \textbf{Compatible with C strings}: You can pass an \texttt{sds} to \texttt{printf()} or any function expecting \texttt{char*}. It works because \texttt{sds} points to a null-terminated buffer.

    \item \textbf{O(1) length}: Normal C strings require \texttt{strlen()} which scans the entire string (O(n)). Redis stores length in the hidden header, so \texttt{sdslen()} is instant.

    \item \textbf{Knows its capacity}: The \texttt{free} field tracks unused space. When concatenating, Redis can check if there's room without scanning.

    \item \textbf{Can grow efficiently}: When buffer is too small, Redis can \texttt{realloc()} the whole thing (struct + buffer) and update the pointer.
\end{enumerate}

\textbf{The Opaque Magic:} Users don't know about the hidden header. They just see a "string" type that works like \texttt{char*} but never needs \texttt{strlen()}. Redis can change the header layout (they've done this several times) without breaking user code!

\textbf{Real-world impact:} This design makes Redis strings 3-4x faster than naive C strings for common operations. When you're processing millions of requests per second, this matters!

\subsection{Example 3: PostgreSQL - Memory Contexts}

\textbf{What is PostgreSQL?} The world's most advanced open source database. Used by Apple, Instagram, Reddit, and countless enterprises.

\textbf{The Problem:} In a database, memory allocation is complicated. You might allocate thousands of small objects for a query, then need to free them all at once. Calling \texttt{free()} thousands of times is slow and error-prone.

\textbf{The Pattern:} PostgreSQL uses "memory contexts" - opaque handles to memory arenas.

\begin{lstlisting}
// In PostgreSQL header (palloc.h) - What users see:
typedef struct MemoryContextData *MemoryContext;  // Opaque!

// Create a new memory context
MemoryContext AllocSetContextCreate(
    MemoryContext parent,
    const char *name,
    Size minContextSize,
    Size initBlockSize,
    Size maxBlockSize
);

// Allocate from a context
void *MemoryContextAlloc(MemoryContext context, Size size);

// Free ALL memory in context at once!
void MemoryContextReset(MemoryContext context);

// Delete entire context
void MemoryContextDelete(MemoryContext context);
\end{lstlisting}

\textbf{The Secret (aset.c):} The implementation uses a pool allocator with multiple blocks.

\begin{lstlisting}
// Simplified version of the real structure:
typedef struct MemoryContextData {
    NodeTag type;                    // Type identifier
    MemoryContextMethods *methods;   // VTable for operations!
    MemoryContext parent;            // Parent context
    MemoryContext firstchild;        // Child contexts
    MemoryContext nextchild;         // Sibling contexts
    char *name;                      // For debugging
    bool isReset;                    // Has been reset?
    // ... more fields for tracking
} MemoryContextData;

// Different implementations use different methods:
typedef struct MemoryContextMethods {
    void *(*alloc)(MemoryContext context, Size size);
    void (*free_p)(MemoryContext context, void *pointer);
    void *(*realloc)(MemoryContext context, void *ptr, Size size);
    void (*reset)(MemoryContext context);
    void (*delete_context)(MemoryContext context);
    // ... more method pointers
} MemoryContextMethods;
\end{lstlisting}

\textbf{How It Works in Practice:}

\begin{lstlisting}
// Example: Processing a database query

// Create a context for this query
MemoryContext query_context = AllocSetContextCreate(
    CurrentMemoryContext,
    "Query Processing",
    ALLOCSET_DEFAULT_SIZES
);

// Switch to this context (all allocations go here now)
MemoryContext old_context = MemoryContextSwitchTo(query_context);

// Allocate lots of stuff (parse trees, execution plans, results)
QueryPlan *plan = palloc(sizeof(QueryPlan));
ResultSet *results = palloc(sizeof(ResultSet));
// ... thousands more allocations

// Execute the query
execute_query(plan, results);

// Send results to client
send_to_client(results);

// Clean up - ONE CALL frees EVERYTHING!
MemoryContextSwitchTo(old_context);
MemoryContextDelete(query_context);

// All those allocations? Gone. No memory leaks possible!
\end{lstlisting}

\textbf{Why This Is Brilliant:}

\begin{enumerate}
    \item \textbf{No memory leaks}: Even if query execution throws an error, you can reset the context and recover. No hunting for which allocations succeeded.

    \item \textbf{Fast cleanup}: Freeing thousands of objects = one function call instead of thousands of \texttt{free()} calls.

    \item \textbf{Hierarchical}: Contexts can have child contexts. Deleting parent deletes all children automatically.

    \item \textbf{Multiple implementations}: PostgreSQL has AllocSet (default), Slab (for fixed-size objects), and Generation (for append-only patterns). All use the same opaque \texttt{MemoryContext} type!
\end{enumerate}

\textbf{The Opaque Magic:} User code doesn't know if they're using AllocSet, Slab, or Generation allocators. The opaque pointer and VTable pattern lets PostgreSQL swap implementations transparently.

\subsection{Example 4: NGINX - Connection Objects}

\textbf{What is NGINX?} A web server powering over 400 million websites. It's famous for handling 10,000+ simultaneous connections on modest hardware.

\textbf{The Pattern:} NGINX uses opaque pointers for network connections.

\begin{lstlisting}
// In NGINX headers (ngx_connection.h):
typedef struct ngx_connection_s ngx_connection_t;  // Opaque!

// You never see the full definition unless you're in core NGINX code
struct ngx_connection_s {
    void *data;                  // User can attach custom data
    ngx_event_t *read;           // Read event handler
    ngx_event_t *write;          // Write event handler

    ngx_socket_t fd;             // File descriptor

    ngx_recv_pt recv;            // Function pointer for receiving
    ngx_send_pt send;            // Function pointer for sending
    ngx_recv_chain_pt recv_chain;
    ngx_send_chain_pt send_chain;

    ngx_listening_t *listening;  // Listening socket config

    off_t sent;                  // Bytes sent

    ngx_log_t *log;              // Connection-specific log

    ngx_pool_t *pool;            // Memory pool for this connection

    // SSL/TLS specific
    ngx_ssl_connection_t *ssl;

    // Buffering
    ngx_buf_t *buffer;

    // ... 30+ more fields for timeouts, flags, peer info, etc.
};
\end{lstlisting}

\textbf{How It's Used:}

\begin{lstlisting}
// HTTP module handling a request
static void
ngx_http_process_request(ngx_http_request_t *r)
{
    ngx_connection_t *c = r->connection;  // Get connection

    // Read from connection (opaque call)
    n = c->recv(c, buffer, size);

    // Check connection state
    if (c->read->timedout) {
        // Handle timeout
        ngx_http_close_request(r, NGX_HTTP_REQUEST_TIME_OUT);
        return;
    }

    // Write response
    c->send(c, response, length);

    // Log to connection-specific logger
    ngx_log_error(NGX_LOG_INFO, c->log, 0, "Request processed");
}
\end{lstlisting}

\textbf{Why This Is Brilliant:}

\begin{enumerate}
    \item \textbf{Polymorphic I/O}: The \texttt{recv} and \texttt{send} fields are function pointers! For regular TCP, they point to \texttt{ngx\_unix\_recv} and \texttt{ngx\_unix\_send}. For SSL connections, they point to \texttt{ngx\_ssl\_recv} and \texttt{ngx\_ssl\_send}. Same opaque connection type handles both!

    \item \textbf{Memory pool per connection}: Each connection has its own memory pool. When connection closes, one call frees all memory allocated for that connection. No leaks!

    \item \textbf{Extensible}: New connection types (HTTP/2, QUIC) can be added by creating new implementations. User code doesn't change.

    \item \textbf{Performance}: By keeping all connection state in one structure, CPU cache is happy (good locality of reference).
\end{enumerate}

\textbf{The Opaque Magic:} HTTP modules don't need to know if they're dealing with HTTP/1.1, HTTP/2, SSL, or plain TCP. They just call \texttt{c->recv()} and \texttt{c->send()}. NGINX's core sets up the right function pointers based on connection type.

\subsection{Example 5: Git - Object Database}

\textbf{What is Git?} The version control system that revolutionized software development. Every object (commit, tree, blob, tag) is stored in an object database.

\textbf{The Pattern:} Git uses opaque object IDs (SHA-1 hashes) as handles.

\begin{lstlisting}
// In Git's object.h:
struct object_id {
    unsigned char hash[GIT_MAX_RAWSZ];  // 20 bytes for SHA-1
};

// Opaque structure - details hidden
struct object {
    unsigned parsed : 1;
    unsigned type : 3;     // commit, tree, blob, or tag
    unsigned flags : 28;
    struct object_id oid;  // The hash
};

// Public API - uses opaque pointers:
struct object *parse_object(const struct object_id *oid);
struct commit *lookup_commit(const struct object_id *oid);
struct tree *lookup_tree(const struct object_id *oid);
\end{lstlisting}

\textbf{How It Works:}

\begin{lstlisting}
// Real Git code (simplified):

// User has a commit hash (like "a3b5c...")
struct object_id oid;
get_oid_hex("a3b5c...", &oid);  // Parse hex to binary

// Look up the commit - Git finds it in object database
struct commit *commit = lookup_commit(&oid);

// Git reads from .git/objects/a3/b5c...
// Parses the object
// Returns a commit struct

// Access commit data
struct commit_list *parents = commit->parents;
struct tree *tree = commit->tree;
const char *message = commit->buffer;

// But users never see how objects are stored on disk!
// Could be loose objects, packed objects, or network protocol
\end{lstlisting}

\textbf{Why This Is Brilliant:}

\begin{enumerate}
    \item \textbf{Content-addressable}: The hash IS the pointer! If you have the hash, you can find the object. No memory addresses needed.

    \item \textbf{Immutable}: Once created, objects never change (content defines hash). This makes caching and sharing trivial.

    \item \textbf{Multiple storage}: Git can store objects as:
    \begin{itemize}
        \item Loose files (.git/objects/XX/XXXXXX...)
        \item Packed files (.git/objects/pack/pack-*.pack)
        \item Network protocol (git:// or https://)
    \end{itemize}
    User code doesn't care! It just calls \texttt{lookup\_commit()} with a hash.

    \item \textbf{Deduplication}: Identical content = same hash = same object. Automatic deduplication across entire repository history!
\end{enumerate}

\textbf{The Opaque Magic:} When you do \texttt{git checkout}, Git looks up commits and trees by hash. It doesn't care if those objects are in a pack file, loose files, or being fetched from a remote server. The opaque \texttt{struct object} pointer works the same way for all cases.

\section{Production Gotcha: Incomplete Types and Linking}

Here's something that bites beginners: the incomplete type trick only works because of separate compilation.

\begin{lstlisting}
// mylib.h - Header file
typedef struct MyObject MyObject;  // Incomplete type

// mylib.c - Implementation file
struct MyObject {  // Complete type definition
    int data;
};

// When you compile user.c:
// - Compiler sees: typedef struct MyObject MyObject;
// - Compiler knows: MyObject exists, can point to it
// - Compiler doesn't know: size, layout, members
// - sizeof(MyObject) = ERROR: incomplete type
// - MyObject* ptr = OK: pointer to incomplete type

// When you LINK:
// - Linker connects myobject_create() call to implementation
// - Linker doesn't care about struct layout
// - Only function symbols need to match

// This is why you can ship:
// - mylib.h (header with forward declaration)
// - libmylib.so (compiled code with full definition)
// Users compile against .h, link against .so
// They never see the struct definition!
\end{lstlisting}

\section{Advanced: Symbol Visibility and Shared Libraries}

Professional libraries use symbol visibility to control what users can see:

\begin{lstlisting}
// In your header (public API)
#ifdef _WIN32
    #ifdef MYLIB_EXPORTS
        #define MYLIB_API __declspec(dllexport)
    #else
        #define MYLIB_API __declspec(dllimport)
    #endif
#else
    #define MYLIB_API __attribute__((visibility("default")))
#endif

// Public API - exported
MYLIB_API MyObject* myobject_create(void);
MYLIB_API void myobject_destroy(MyObject* obj);

// In your implementation file
// Private helper - NOT exported
__attribute__((visibility("hidden")))
static void internal_helper(MyObject* obj) {
    // This function doesn't appear in the shared library's
    // symbol table. Users can't accidentally call it.
}

// Check exported symbols:
// $ nm -D libmylib.so | grep " T "
// Only sees: myobject_create, myobject_destroy
// Doesn't see: internal_helper, struct definition
\end{lstlisting}

\begin{warningbox}
By default, GCC exports ALL symbols from a shared library. Use \texttt{-fvisibility=hidden} and mark only public API as visible. This reduces symbol table size, speeds up dynamic linking, and prevents symbol conflicts! Think of it as not airing your dirty laundry in public---keep your internal functions internal.
\end{warningbox}

\section{Common Mistakes and How to Avoid Them}

\subsection{Mistake 1: Forgetting NULL Checks}

\begin{lstlisting}
// BAD - crashes on NULL
void myobject_set_value(MyObject* obj, int value) {
    obj->value = value;  // SEGFAULT if obj is NULL!
}

// GOOD - defensive programming
void myobject_set_value(MyObject* obj, int value) {
    if (!obj) return;  // or assert(obj != NULL);
    obj->value = value;
}

// BETTER - return error code
int myobject_set_value(MyObject* obj, int value) {
    if (!obj) return -1;
    obj->value = value;
    return 0;
}

// In production code, NULL pointer crashes are the #1 bug
// Always validate opaque pointers at function entry
// (Your 3 AM self will thank your current self)
// (Also your users will send fewer angry emails)
\end{lstlisting}

\subsection{Mistake 2: Double-Free Bugs}

\begin{lstlisting}
// Dangerous pattern:
MyObject* obj = myobject_create();
myobject_destroy(obj);
myobject_destroy(obj);  // Double free! Undefined behavior!
                        // This is how memory corruption parties start

// Solution 1: Set to NULL after free
void myobject_destroy(MyObject** obj_ptr) {
    if (obj_ptr && *obj_ptr) {
        free(*obj_ptr);
        *obj_ptr = NULL;  // Prevent double-free
    }
}

// Usage:
MyObject* obj = myobject_create();
myobject_destroy(&obj);  // obj becomes NULL
myobject_destroy(&obj);  // Safe - does nothing

// Solution 2: Reference counting (like COM, Python)
MyObject* myobject_retain(MyObject* obj) {
    if (obj) obj->ref_count++;
    return obj;
}

void myobject_release(MyObject* obj) {
    if (obj && --obj->ref_count == 0) {
        // Actually free when ref count reaches 0
        free(obj);
    }
}
\end{lstlisting}

\subsection{Mistake 3: Memory Leaks from Exception Paths}

\begin{lstlisting}
// BAD - leaks on error
MyObject* create_and_init(const char* config) {
    MyObject* obj = myobject_create();

    if (!load_config(config)) {
        return NULL;  // LEAK! obj is never freed
    }

    return obj;
}

// GOOD - cleanup on all error paths
MyObject* create_and_init(const char* config) {
    MyObject* obj = myobject_create();
    if (!obj) return NULL;

    if (!load_config(config)) {
        myobject_destroy(obj);  // Clean up!
        return NULL;
    }

    return obj;
}

// BETTER - use goto cleanup pattern (Linux kernel style)
MyObject* create_and_init(const char* config) {
    MyObject* obj = NULL;
    char* buffer = NULL;
    FILE* f = NULL;

    obj = myobject_create();
    if (!obj) goto cleanup;

    buffer = malloc(1024);
    if (!buffer) goto cleanup;

    f = fopen(config, "r");
    if (!f) goto cleanup;

    // ... do work ...

    // Success path
    fclose(f);
    free(buffer);
    return obj;

cleanup:
    // Error path - cleanup in reverse order
    if (f) fclose(f);
    free(buffer);
    myobject_destroy(obj);
    return NULL;
}
\end{lstlisting}

\section{Advanced: Multiple Implementations}

One powerful use of opaque pointers is supporting multiple backends:

\begin{lstlisting}
// Public header - same for all implementations
typedef struct Database Database;

Database* database_create(const char* type);
int database_query(Database* db, const char* sql);
void database_close(Database* db);

// Implementation 1: SQLite (database_sqlite.c)
#include <sqlite3.h>

struct Database {
    const char* type;  // "sqlite"
    sqlite3* handle;
    // SQLite-specific fields
};

// Implementation 2: PostgreSQL (database_postgres.c)
#include <libpq-fe.h>

struct Database {
    const char* type;  // "postgres"
    PGconn* conn;
    // Postgres-specific fields
};

// Factory function chooses implementation at runtime
Database* database_create(const char* type) {
    if (strcmp(type, "sqlite") == 0) {
        return create_sqlite_database();
    } else if (strcmp(type, "postgres") == 0) {
        return create_postgres_database();
    }
    return NULL;
}

// The query function can dispatch based on type:
int database_query(Database* db, const char* sql) {
    if (!db || !sql) return -1;

    if (strcmp(db->type, "sqlite") == 0) {
        return sqlite_do_query(db, sql);
    } else if (strcmp(db->type, "postgres") == 0) {
        return postgres_do_query(db, sql);
    }

    return -1;
}

// Real-world example: OpenSSL uses this for crypto engines
// Same API, different implementations (hardware, software, etc.)
\end{lstlisting}

\section{Pro Pattern: VTable for Polymorphism}

Here's how professionals implement true polymorphism in C:

\begin{lstlisting}
// Function pointer table (VTable)
typedef struct {
    int (*query)(void* self, const char* sql);
    void (*close)(void* self);
    const char* (*get_error)(void* self);
} DatabaseVTable;

// Base "class"
struct Database {
    DatabaseVTable* vtable;  // First member!
    void* impl;  // Implementation-specific data
};

// SQLite implementation
typedef struct {
    sqlite3* handle;
    char last_error[256];
} SQLiteImpl;

int sqlite_query(void* self, const char* sql) {
    Database* db = (Database*)self;
    SQLiteImpl* impl = (SQLiteImpl*)db->impl;
    // Use impl->handle...
    return 0;
}

void sqlite_close(void* self) {
    Database* db = (Database*)self;
    SQLiteImpl* impl = (SQLiteImpl*)db->impl;
    sqlite3_close(impl->handle);
    free(impl);
    free(db);
}

const char* sqlite_get_error(void* self) {
    Database* db = (Database*)self;
    SQLiteImpl* impl = (SQLiteImpl*)db->impl;
    return impl->last_error;
}

// VTable instance
static DatabaseVTable sqlite_vtable = {
    .query = sqlite_query,
    .close = sqlite_close,
    .get_error = sqlite_get_error
};

// Constructor
Database* database_create_sqlite(const char* path) {
    Database* db = malloc(sizeof(Database));
    SQLiteImpl* impl = malloc(sizeof(SQLiteImpl));

    if (!db || !impl) {
        free(db);
        free(impl);
        return NULL;
    }

    db->vtable = &sqlite_vtable;
    db->impl = impl;

    sqlite3_open(path, &impl->handle);

    return db;
}

// Polymorphic call - works for ANY database type!
int database_query(Database* db, const char* sql) {
    if (!db || !db->vtable || !db->vtable->query) {
        return -1;
    }
    return db->vtable->query(db, sql);
}

// This is EXACTLY how GObject (GTK) works!
// Also similar to COM objects in Windows
// And C++ virtual functions under the hood
// Turns out, we were doing OOP before it was cool
\end{lstlisting}

\begin{tipbox}
The VTable must be the FIRST member of the struct. This allows safe casting between base and derived types. C guarantees that a pointer to a struct points to its first member!
\end{tipbox}

\section{Platform-Specific Considerations}

\subsection{Windows DLL Export/Import}

\begin{lstlisting}
// mylib.h
#ifdef _WIN32
    #ifdef BUILDING_MYLIB
        #define MYLIB_API __declspec(dllexport)
    #else
        #define MYLIB_API __declspec(dllimport)
    #endif
#else
    #define MYLIB_API
#endif

// Mark all public functions
MYLIB_API MyObject* myobject_create(void);
MYLIB_API void myobject_destroy(MyObject* obj);

// When building the DLL:
// cl /DBUILDING_MYLIB /LD mylib.c

// When using the DLL:
// cl user.c mylib.lib
\end{lstlisting}

\subsection{Structure Packing and Alignment}

\begin{lstlisting}
// On 64-bit systems, this struct is 24 bytes:
struct MyObject {
    int value;        // 4 bytes
    // 4 bytes padding for alignment
    char* name;       // 8 bytes
    int flags;        // 4 bytes
    // 4 bytes padding at end
};

// Reorder for better packing (16 bytes):
struct MyObject {
    char* name;       // 8 bytes
    int value;        // 4 bytes
    int flags;        // 4 bytes
};

// For network protocols, force packing:
#pragma pack(push, 1)
struct NetworkPacket {
    uint32_t magic;   // 4 bytes, no padding
    uint16_t version; // 2 bytes, no padding
    uint8_t type;     // 1 byte, no padding
};
#pragma pack(pop)

// But users never see this because it's OPAQUE!
// You can reorganize for performance anytime
\end{lstlisting}

\section{Memory Debugging with Opaque Types}

\begin{lstlisting}
// Add magic numbers for debugging
#define MYOBJECT_MAGIC 0xDEADBEEF

struct MyObject {
    uint32_t magic;  // First member
    int value;
    char* name;
    // ... rest of struct
};

MyObject* myobject_create(void) {
    MyObject* obj = malloc(sizeof(MyObject));
    if (obj) {
        obj->magic = MYOBJECT_MAGIC;
        obj->value = 0;
        obj->name = NULL;
    }
    return obj;
}

// Validate pointer in every function
static inline int myobject_is_valid(const MyObject* obj) {
    return obj && obj->magic == MYOBJECT_MAGIC;
}

void myobject_destroy(MyObject* obj) {
    if (!myobject_is_valid(obj)) {
        fprintf(stderr, "ERROR: Invalid MyObject pointer!\n");
        abort();  // Crash immediately in debug builds
    }

    obj->magic = 0;  // Clear magic before freeing
    free(obj->name);
    free(obj);
}

// Catches:
// - NULL pointers (the classic)
// - Freed objects (magic is cleared)
// - Random garbage pointers (someone's having a bad day)
// - Wrong type pointers (someone passed us a Cat when we wanted a Dog)

// Valgrind and AddressSanitizer love this pattern!
// (And so will you, when it saves you from a 6-hour debugging session)
\end{lstlisting}

\section{When NOT to Use Opaque Pointers}

Opaque pointers aren't always the answer. Sometimes they're overkill, like using a sledgehammer to crack a peanut:

\begin{itemize}
    \item \textbf{POD types}: Simple structs like \texttt{Point\{int x, y;\}} don't need hiding
    \item \textbf{Performance-critical tight loops}: Extra indirection costs CPU cycles
    \item \textbf{Stack allocation needed}: Opaque types must be heap-allocated
    \item \textbf{Embedded systems}: Limited heap, prefer stack allocation
    \item \textbf{Header-only libraries}: Convenience over encapsulation
    \item \textbf{Internal-only code}: No need for ABI stability
\end{itemize}

\begin{lstlisting}
// Good use: Public API, needs ABI stability
typedef struct Database Database;
Database* db_open(const char* path);

// Bad use: Simple 2D point
typedef struct Point Point;
Point* point_create(int x, int y);
// Just use: struct Point { int x, y; };
// Don't be that person who over-engineers everything

// Performance example:
// BAD - extra indirection in tight loop
for (int i = 0; i < 1000000; i++) {
    int x = point_get_x(points[i]);  // Function call overhead
    int y = point_get_y(points[i]);
    process(x, y);
}

// GOOD - direct access
for (int i = 0; i < 1000000; i++) {
    process(points[i].x, points[i].y);  // Inline, fast
}
\end{lstlisting}

\section{Real Production Example: OpenSSL - The 25-Year Evolution}

Let's examine how OpenSSL uses opaque pointers to maintain binary compatibility across decades. This is the ultimate test of the pattern.

\subsection{Example 6: OpenSSL - SSL/TLS Connections}

\textbf{What is OpenSSL?} The cryptographic library that secures most of the internet. Used by Apache, NGINX, Node.js, Python, Ruby, and countless other tools. If you've ever seen "https://" in a URL, OpenSSL (or a fork like BoringSSL) was probably involved.

\textbf{The Challenge:} OpenSSL was first released in 1998. It needs to support new TLS versions (TLS 1.3), new cipher suites, new features, while still working with programs compiled years ago.

\textbf{The Pattern:} Everything is opaque! \texttt{SSL}, \texttt{SSL\_CTX}, \texttt{BIO}, \texttt{X509}, etc.

\begin{lstlisting}
// In openssl/ssl.h (public header) - What users see:
typedef struct ssl_st SSL;                // Opaque!
typedef struct ssl_ctx_st SSL_CTX;        // Opaque!
typedef struct ssl_method_st SSL_METHOD;  // Opaque!

// Create SSL context (shared settings for multiple connections)
SSL_CTX* SSL_CTX_new(const SSL_METHOD* method);

// Create SSL connection object
SSL* SSL_new(SSL_CTX* ctx);

// Perform handshake
int SSL_connect(SSL* ssl);
int SSL_accept(SSL* ssl);

// Read/write encrypted data
int SSL_read(SSL* ssl, void* buf, int num);
int SSL_write(SSL* ssl, const void* buf, int num);

// Clean up
void SSL_free(SSL* ssl);
void SSL_CTX_free(SSL_CTX* ctx);

// Query functions (no direct field access!)
int SSL_version(const SSL* ssl);
const SSL_CIPHER* SSL_get_current_cipher(const SSL* ssl);
long SSL_get_verify_result(const SSL* ssl);
\end{lstlisting}

\textbf{The Secret (ssl/ssl\_local.h):} The actual structures are MASSIVE and constantly evolving.

\begin{lstlisting}
// Simplified version of the real structure:
struct ssl_st {
    // Protocol version
    int version;     // SSL 3.0, TLS 1.0, 1.1, 1.2, 1.3...

    // Method pointers (polymorphism!)
    const SSL_METHOD* method;

    // I/O abstractions
    BIO* rbio;       // Read BIO (could be socket, memory, filter...)
    BIO* wbio;       // Write BIO

    // Session information
    SSL_SESSION* session;

    // Cipher information
    STACK_OF(SSL_CIPHER)* cipher_list;
    const SSL_CIPHER* s3->tmp.new_cipher;

    // Handshake state machine
    OSSL_STATEM statem;  // State machine for handshake

    // Buffers
    struct {
        unsigned char* buf;
        size_t len;
    } s3->rrec;  // Read record

    // Security parameters
    int verify_mode;
    int (*verify_callback)(int, X509_STORE_CTX*);

    // Extensions
    TLSEXT_TYPE* extensions;

    // Threading
    CRYPTO_RWLOCK* lock;

    // ... 190+ more fields for:
    // - Certificate chains
    // - Session tickets
    // - ALPN/NPN negotiation
    // - Renegotiation state
    // - Heartbeat
    // - DTLS specifics
    // - Custom extensions
    // - Statistics
    // - Debugging info
    // And more!
};
\end{lstlisting}

\textbf{Real-World Usage Example:}

\begin{lstlisting}
// Example: HTTPS client (simplified)

// Initialize OpenSSL
SSL_library_init();
SSL_load_error_strings();

// Create SSL context (TLS 1.2 or higher)
SSL_CTX* ctx = SSL_CTX_new(TLS_client_method());

// Load CA certificates for verification
SSL_CTX_load_verify_locations(ctx, "/etc/ssl/certs/ca-certificates.crt", NULL);

// Connect to server
int sock = socket_connect("www.example.com", 443);

// Create SSL connection object
SSL* ssl = SSL_new(ctx);
SSL_set_fd(ssl, sock);  // Attach to socket

// Perform TLS handshake
if (SSL_connect(ssl) != 1) {
    ERR_print_errors_fp(stderr);
    exit(1);
}

// Verify certificate
if (SSL_get_verify_result(ssl) != X509_V_OK) {
    printf("Certificate verification failed!\n");
    exit(1);
}

// Send HTTPS request
const char* request = "GET / HTTP/1.1\r\nHost: www.example.com\r\n\r\n";
SSL_write(ssl, request, strlen(request));

// Read response
char buffer[4096];
int bytes = SSL_read(ssl, buffer, sizeof(buffer) - 1);
buffer[bytes] = '\0';
printf("Response: %s\n", buffer);

// Clean up
SSL_shutdown(ssl);
SSL_free(ssl);
close(sock);
SSL_CTX_free(ctx);
\end{lstlisting}

\textbf{Why This Is Brilliant:}

\begin{enumerate}
    \item \textbf{25 years of evolution}: The \texttt{SSL} structure has grown from ~50 fields in 1998 to over 200 fields today. Programs compiled against OpenSSL 0.9.6 (year 2000) still work with OpenSSL 3.0 (year 2021)!

    \item \textbf{Multiple protocol versions}: Same \texttt{SSL*} type handles SSL 3.0 (obsolete), TLS 1.0-1.3, and DTLS. The \texttt{method} field's function pointers implement protocol-specific behavior.

    \item \textbf{Abstraction layers}: The \texttt{BIO} (Basic I/O) abstraction means SSL can work over:
    \begin{itemize}
        \item TCP sockets
        \item UDP (for DTLS)
        \item Memory buffers (for testing)
        \item Filters (compression, encryption)
        \item Custom transports (QUIC, SCTP)
    \end{itemize}
    User code doesn't change! Just swap the BIO.

    \item \textbf{Security updates without recompilation}: When Heartbleed (2014) and other bugs were found, OpenSSL fixed them in the internal structures. Applications didn't need recompilation---just link against the new library.

    \item \textbf{New features transparently}: TLS 1.3 added in 2018. Programs written in 2010 can use TLS 1.3 by just updating the OpenSSL library, no code changes needed!
\end{enumerate}

\textbf{The Opaque Magic at Scale:}

Let's see how deep the abstraction goes:

\begin{lstlisting}
// Everything is opaque all the way down!

SSL*              // Opaque connection
 +-> SSL_CTX*          // Opaque context (shared settings)
 +-> SSL_SESSION*      // Opaque session (for resumption)
 +-> SSL_METHOD*       // Opaque method table (protocol impl)
 +-> BIO*              // Opaque I/O (network, memory, filter)
 |    +-> BIO_METHOD*       // Opaque I/O methods
 +-> X509*             // Opaque certificate
 |    +-> X509_NAME*        // Opaque subject/issuer
 |    +-> EVP_PKEY*         // Opaque public key
 |    +-> X509_STORE*       // Opaque cert store
 +-> SSL_CIPHER*       // Opaque cipher info
 +-> STACK_OF(X509)*   // Opaque stack (dynamic array)

// Users NEVER see the internals of any of these!
// All access is through functions
\end{lstlisting}

\textbf{Real-world Impact - The Heartbleed Example:}

In 2014, the Heartbleed bug was discovered in OpenSSL. The bug was in the internal heartbeat handling code. Here's what happened:

\begin{lstlisting}
// BEFORE Heartbleed fix (vulnerable):
// Inside ssl/d1_both.c (users never see this file)
int dtls1_process_heartbeat(SSL *s) {
    unsigned char *p = &s->s3->rrec.data[0];
    unsigned short hbtype;
    unsigned int payload;

    hbtype = *p++;
    n2s(p, payload);  // Read payload length from attacker

    // BUG! No validation of payload length!
    // Attacker could claim 64KB even if actual data is 1 byte

    memcpy(buffer, p, payload);  // Read beyond bounds!
    send_heartbeat_response(s, buffer, payload);
}

// AFTER Heartbleed fix:
int dtls1_process_heartbeat(SSL *s) {
    unsigned char *p = &s->s3->rrec.data[0];
    unsigned short hbtype;
    unsigned int payload, actual_length;

    hbtype = *p++;
    n2s(p, payload);

    // FIX: Validate payload length!
    actual_length = s->s3->rrec.length - 3;
    if (payload > actual_length) {
        // Attacker lying about length - reject!
        return 0;
    }

    memcpy(buffer, p, payload);  // Now safe!
    send_heartbeat_response(s, buffer, payload);
}
\end{lstlisting}

\textbf{The fix was internal.} Because \texttt{SSL} is opaque:

\begin{itemize}
    \item Users didn't need to recompile their applications
    \item Just update OpenSSL library (apt-get upgrade, yum update)
    \item All applications immediately protected
    \item No source code changes needed
    \item No ABI breakage
\end{itemize}

If \texttt{struct ssl\_st} was exposed in headers, users might have been directly accessing \texttt{s->s3->rrec.data}. Changing the internal layout would break their code!

\textbf{Lessons from OpenSSL:}

\begin{enumerate}
    \item \textbf{Opaque pointers enable security updates}: You can fix bugs in internal code without breaking users

    \item \textbf{Opaque pointers enable evolution}: Add TLS 1.3 support without changing the API

    \item \textbf{Accessor functions are mandatory}: Every query must go through a function (\texttt{SSL\_version}, \texttt{SSL\_get\_current\_cipher}, etc.)

    \item \textbf{Documentation is critical}: With 200+ internal fields, good documentation is the only way users know what's available

    \item \textbf{Versioning matters}: OpenSSL has \texttt{OPENSSL\_VERSION\_NUMBER} so code can adapt to different versions when needed
\end{enumerate}

\textbf{The Bottom Line:}

OpenSSL protects billions of connections per day. It's evolved from SSL 2.0 to TLS 1.3, from 56-bit DES to 256-bit AES, from RSA to elliptic curves, from being a few thousand lines to over 500,000 lines of code. Through all this, the same simple opaque API has remained:

\begin{lstlisting}
SSL* ssl = SSL_new(ctx);
SSL_connect(ssl);
SSL_write(ssl, data, len);
SSL_read(ssl, buffer, size);
SSL_free(ssl);
\end{lstlisting}

That's the power of opaque pointers. 25 years of evolution, billions of users, and the API still looks almost the same as it did in 1998.

\section{Best Practices from 20+ Years of C}

\begin{enumerate}
    \item \textbf{Always validate}: Check for NULL, check magic numbers (paranoia is a feature, not a bug)
    \item \textbf{Document ownership}: Who allocates? Who frees? (Avoid the "I thought YOU were freeing it" conversation)
    \item \textbf{Const correctness}: \texttt{const MyObject*} for read-only operations
    \item \textbf{Error handling}: Return status codes, set errno
    \item \textbf{Thread safety}: Document if functions are thread-safe (your users will ask at 2 AM)
    \item \textbf{Naming convention}: \texttt{prefix\_typename\_operation} (e.g., \texttt{mylib\_object\_create})
    \item \textbf{Include guards}: Always use header guards (learned this one the hard way, didn't we?)
    \item \textbf{Versioning}: Consider version numbers in struct for future compatibility
    \item \textbf{Testing}: Mock implementations for unit testing
    \item \textbf{Documentation}: Document lifetime, ownership, thread-safety
\end{enumerate}

\section{Advanced Pattern: Handle Tables (The ID System)}

Here's a pattern used by game engines, database systems, and operating systems that textbooks never mention: instead of returning raw pointers, return integer handles that index into a table. This is the "we don't trust you with real pointers" pattern, and honestly, that's probably wise.

\subsection*{The Hotel Room Analogy}

Imagine you're running a hotel with 1000 rooms:

\textbf{Bad approach (raw pointers):}
\begin{itemize}
    \item Give guests the actual physical address of their room: "123 Main St, Room 5, Bed \#2"
    \item If you renovate and move things around, all those addresses become invalid
    \item Guests could find rooms they're not supposed to access
    \item If a guest leaves but keeps their address, they might barge into the new guest's room! (Awkward.)
\end{itemize}

\textbf{Good approach (handle tables):}
\begin{itemize}
    \item Give guests a room number: "Room 42"
    \item You maintain a registry: Room 42 -> currently occupied by Guest Smith
    \item When Guest Smith checks out, you mark Room 42 as "vacant"
    \item If someone tries to use an old room number, you check your registry: "Sorry, that room is vacant now"
    \item You can move guests to different rooms without changing their room number (update your registry)
    \item Room numbers are easy to write down, remember, and verify
\end{itemize}

That's exactly what handle tables do! Instead of giving users raw memory addresses (pointers), you give them IDs (handles) that you can validate and control.

\subsection{Why Handle Tables?}

Let's break down each benefit with examples:

\begin{enumerate}
    \item \textbf{Detect stale pointers}: Can validate if handle is still valid
    \begin{itemize}
        \item Problem: User calls \texttt{destroy()}, but keeps using the pointer -> crash!
        \item Solution: Handle becomes invalid after destroy. Next use returns error instead of crashing
        \item Like: Hotel room key card stops working after checkout
    \end{itemize}

    \item \textbf{Stable references}: Handles don't change even if object moves in memory
    \begin{itemize}
        \item Problem: If you use \texttt{realloc()} to grow an array, all pointers into it become invalid
        \item Solution: Handles remain the same; you just update the table
        \item Like: Your hotel room number stays "42" even if the hotel renovates
    \end{itemize}

    \item \textbf{Serialization}: Integers are easier to save/load than pointers
    \begin{itemize}
        \item Problem: Can't save a pointer to disk (it's meaningless when you restart)
        \item Solution: Save the handle (just an integer). When loading, look it up in the table
        \item Like: Saving "Room 42" in your reservation vs saving "Third floor, second hallway, left door"
    \end{itemize}

    \item \textbf{Cross-process}: Can share handles between processes
    \begin{itemize}
        \item Problem: Pointers are only valid in one process's memory space
        \item Solution: Multiple processes can agree on handle meanings
        \item Like: Two hotels owned by the same company use the same room numbering system
    \end{itemize}

    \item \textbf{Security}: Prevents pointer arithmetic attacks
    \begin{itemize}
        \item Problem: Malicious user does \texttt{ptr + 10} to access wrong object
        \item Solution: Handles are just numbers; you can't do math to find other objects
        \item Like: Knowing Room 42 doesn't let you calculate how to access the hotel safe
    \end{itemize}

    \item \textbf{Generational IDs}: Detect use-after-free bugs
    \begin{itemize}
        \item Problem: Object is freed, new object is allocated at same address, old pointer accesses wrong object!
        \item Solution: Include a "generation" number in the handle. Each reuse increments the generation
        \item Like: Room 42, Reservation \#7 (vs Room 42, Reservation \#8). Same room, different stays
    \end{itemize}
\end{enumerate}

\begin{lstlisting}
// Handle format: [generation:16][index:16]
// Generation prevents handle reuse bugs
typedef uint32_t ObjectHandle;

#define INVALID_HANDLE 0
#define MAX_OBJECTS 4096

typedef struct {
    MyObject* object;      // Actual object pointer
    uint16_t generation;   // Incremented on free
    uint8_t is_active;     // Is this slot in use?
} ObjectSlot;

typedef struct {
    ObjectSlot slots[MAX_OBJECTS];
    uint32_t next_free;
} ObjectTable;

static ObjectTable g_table = {0};

// Pack handle from generation and index
static inline ObjectHandle make_handle(uint16_t gen, uint16_t idx) {
    return ((uint32_t)gen << 16) | idx;
}

// Unpack handle
static inline uint16_t handle_generation(ObjectHandle h) {
    return (uint16_t)(h >> 16);
}

static inline uint16_t handle_index(ObjectHandle h) {
    return (uint16_t)(h & 0xFFFF);
}

ObjectHandle myobject_create(void) {
    // Find free slot
    for (uint32_t i = 0; i < MAX_OBJECTS; i++) {
        if (!g_table.slots[i].is_active) {
            // Allocate object
            MyObject* obj = malloc(sizeof(MyObject));
            if (!obj) return INVALID_HANDLE;

            // Initialize object
            obj->value = 0;
            obj->name = NULL;

            // Setup slot
            g_table.slots[i].object = obj;
            g_table.slots[i].is_active = 1;

            // Return handle with current generation
            return make_handle(g_table.slots[i].generation, i);
        }
    }

    return INVALID_HANDLE;  // Table full
}

// Validate handle and get object
static MyObject* handle_to_object(ObjectHandle handle) {
    if (handle == INVALID_HANDLE) return NULL;

    uint16_t idx = handle_index(handle);
    uint16_t gen = handle_generation(handle);

    if (idx >= MAX_OBJECTS) return NULL;

    ObjectSlot* slot = &g_table.slots[idx];

    // Check if handle generation matches (detects use-after-free!)
    if (!slot->is_active || slot->generation != gen) {
        return NULL;  // Stale handle!
    }

    return slot->object;
}

void myobject_destroy(ObjectHandle handle) {
    MyObject* obj = handle_to_object(handle);
    if (!obj) return;

    uint16_t idx = handle_index(handle);
    ObjectSlot* slot = &g_table.slots[idx];

    // Free the object
    free(obj->name);
    free(obj);

    // Mark slot as free and increment generation
    slot->object = NULL;
    slot->is_active = 0;
    slot->generation++;  // Next handle for this slot will be different!
}

int myobject_set_value(ObjectHandle handle, int value) {
    MyObject* obj = handle_to_object(handle);
    if (!obj) return -1;  // Invalid handle

    obj->value = value;
    return 0;
}

// Example of use-after-free detection:
ObjectHandle h = myobject_create();  // gen=0, idx=5 -> handle=0x00000005
myobject_destroy(h);                 // Increments gen to 1

// Later, user tries to use old handle:
myobject_set_value(h, 42);           // FAILS! gen=0 but slot gen=1
// Returns -1 instead of crashing!

// This is how Unity game engine handles GameObjects
// And how Windows handles HWNDs (window handles)
\end{lstlisting}

\subsection*{Understanding Handle Tables - Step by Step}

Let's break down this code in simple terms:

\textbf{The Handle Format}

A handle is a 32-bit integer split into two parts:
\begin{itemize}
    \item \textbf{Upper 16 bits}: Generation number (0-65535)
    \item \textbf{Lower 16 bits}: Index into the array (0-65535)
\end{itemize}

Example: Handle value \texttt{0x00050042} means:
\begin{itemize}
    \item Generation 5 (upper 16 bits: 0x0005)
    \item Index 66 (lower 16 bits: 0x0042 = 66 in decimal)
    \item "This is the 5th time we've used slot 66"
\end{itemize}

Think of it like: "Room 66, Reservation \#5"

\textbf{Creating an Object}

When user calls \texttt{myobject\_create()}:

\begin{enumerate}
    \item \textbf{Find a free slot}: Loop through the table looking for \texttt{is\_active == 0}
    \begin{itemize}
        \item Like finding an empty hotel room
        \item If all slots are full, return INVALID\_HANDLE (hotel is fully booked!)
    \end{itemize}

    \item \textbf{Allocate the actual object}: Call malloc to get memory
    \begin{itemize}
        \item This is the actual data storage
        \item The pointer to this is stored in the slot
    \end{itemize}

    \item \textbf{Mark slot as active}: Set \texttt{is\_active = 1}
    \begin{itemize}
        \item "Room is now occupied"
    \end{itemize}

    \item \textbf{Create and return handle}: Combine generation + index
    \begin{itemize}
        \item Handle = (generation << 16) | index
        \item This is the "room number" we give to the user
    \end{itemize}
\end{enumerate}

\textbf{Using a Handle}

When user calls \texttt{myobject\_set\_value(handle, 42)}:

\begin{enumerate}
    \item \textbf{Extract index and generation from handle}:
    \begin{itemize}
        \item Index = lower 16 bits
        \item Generation = upper 16 bits
    \end{itemize}

    \item \textbf{Check if index is valid}: Is it less than MAX\_OBJECTS?
    \begin{itemize}
        \item Like: "Is room number in valid range?"
        \item If not, someone is trying to access room 10000 in a 4096-room hotel!
    \end{itemize}

    \item \textbf{Look up the slot}: Get slot from table
    \begin{itemize}
        \item Look in the hotel registry for that room number
    \end{itemize}

    \item \textbf{Validate generation}: Does handle generation match slot generation?
    \begin{itemize}
        \item This is the magic! If generations don't match, this is a stale handle
        \item Like: "You have a key for Reservation \#5, but we're on Reservation \#6 now"
        \item Someone already checked out and someone new checked in
    \end{itemize}

    \item \textbf{Check if slot is active}: Is someone currently using this slot?
    \begin{itemize}
        \item Even if generation matches, the slot might be vacant
    \end{itemize}

    \item \textbf{Return the object pointer if all checks pass}
    \begin{itemize}
        \item Only now do we give access to the actual object
        \item All those checks happened before touching any memory!
    \end{itemize}
\end{enumerate}

\textbf{Destroying an Object}

When user calls \texttt{myobject\_destroy(handle)}:

\begin{enumerate}
    \item \textbf{Validate and get object}: Use the validation above
    \begin{itemize}
        \item If handle is invalid, do nothing (safe!)
    \end{itemize}

    \item \textbf{Free the actual object}: Call free on the pointer
    \begin{itemize}
        \item Release the actual memory
    \end{itemize}

    \item \textbf{Mark slot as inactive}: Set \texttt{is\_active = 0}
    \begin{itemize}
        \item "Room is now vacant"
    \end{itemize}

    \item \textbf{Increment generation}: \texttt{generation++}
    \begin{itemize}
        \item This is crucial! Now any old handles become invalid
        \item Old handle has generation 5, but slot now has generation 6
        \item Next lookup will fail: "Your reservation \#5 is outdated"
    \end{itemize}
\end{enumerate}

\textbf{The Use-After-Free Detection Example}

\begin{lstlisting}
ObjectHandle h = myobject_create();  // Creates handle: gen=0, idx=5
// Handle value = 0x00000005

myobject_destroy(h);                 // Destroys object, generation becomes 1
// Slot 5 now has: generation=1, is_active=0

// User (wrongly) tries to use old handle:
myobject_set_value(h, 42);
// Extract: gen=0, idx=5 from handle
// Look up slot 5: generation=1, is_active=0
// Compare: handle gen (0) != slot gen (1)
// Result: FAIL! Return -1 instead of crashing!
\end{lstlisting}

Instead of a crash (accessing freed memory), user gets a clean error! This is how professional systems catch bugs early.

\begin{tipbox}
\textbf{Real-world usage:} Handle tables trade memory (fixed-size array) for safety and debuggability.

Who uses this?
\begin{itemize}
    \item \textbf{Unity game engine}: Every GameObject has a handle. When you destroy an object, all references become detectably invalid
    \item \textbf{Windows}: HWND (window handles), HANDLE (file handles). These are handles, not raw pointers!
    \item \textbf{Vulkan/DirectX}: Graphics APIs use handles for GPU resources
    \item \textbf{Databases}: Row IDs are handles into table storage
\end{itemize}

Debugging benefit: You can dump the entire handle table and see:
\begin{itemize}
    \item How many objects are alive (count active slots)
    \item Which slots have been reused most (high generation numbers)
    \item Memory leaks (slots that should be inactive but aren't)
    \item The actual objects for inspection
\end{itemize}

It's like having a complete hotel registry---you know exactly who's checked in, who's checked out, and if anyone's overstayed their welcome!
\end{tipbox}

\subsection{Optimization: Free List}

\begin{lstlisting}
// Instead of scanning for free slots, maintain a free list
typedef struct {
    ObjectSlot slots[MAX_OBJECTS];
    uint16_t free_list[MAX_OBJECTS];  // Indices of free slots
    uint32_t free_count;
} OptimizedObjectTable;

static OptimizedObjectTable g_table;

void init_object_table(void) {
    g_table.free_count = MAX_OBJECTS;
    for (uint32_t i = 0; i < MAX_OBJECTS; i++) {
        g_table.free_list[i] = i;
        g_table.slots[i].is_active = 0;
        g_table.slots[i].generation = 0;
    }
}

ObjectHandle myobject_create(void) {
    if (g_table.free_count == 0) {
        return INVALID_HANDLE;  // No free slots
    }

    // Pop from free list - O(1) instead of O(n) scan
    g_table.free_count--;
    uint16_t idx = g_table.free_list[g_table.free_count];

    MyObject* obj = malloc(sizeof(MyObject));
    if (!obj) {
        g_table.free_count++;  // Return slot to free list
        return INVALID_HANDLE;
    }

    obj->value = 0;
    obj->name = NULL;

    ObjectSlot* slot = &g_table.slots[idx];
    slot->object = obj;
    slot->is_active = 1;

    return make_handle(slot->generation, idx);
}

void myobject_destroy(ObjectHandle handle) {
    MyObject* obj = handle_to_object(handle);
    if (!obj) return;

    uint16_t idx = handle_index(handle);
    ObjectSlot* slot = &g_table.slots[idx];

    free(obj->name);
    free(obj);

    slot->object = NULL;
    slot->is_active = 0;
    slot->generation++;

    // Return to free list
    g_table.free_list[g_table.free_count] = idx;
    g_table.free_count++;
}

// Now creation/deletion is O(1) instead of O(n)!
// This is production-grade code
\end{lstlisting}

\section{Pattern: Capabilities and Permissions}

Professional APIs often need fine-grained access control. Here's how to implement it with opaque pointers:

\begin{lstlisting}
// Different capability levels
typedef enum {
    CAPABILITY_READ  = 1 << 0,  // 0x01
    CAPABILITY_WRITE = 1 << 1,  // 0x02
    CAPABILITY_EXEC  = 1 << 2,  // 0x04
    CAPABILITY_ADMIN = 1 << 3,  // 0x08
} Capability;

struct MyObject {
    int value;
    char* data;
    uint32_t capabilities;  // Bitmask of allowed operations
};

// Create object with specific capabilities
MyObject* myobject_create_with_caps(uint32_t caps) {
    MyObject* obj = malloc(sizeof(MyObject));
    if (obj) {
        obj->value = 0;
        obj->data = NULL;
        obj->capabilities = caps;
    }
    return obj;
}

// Check if operation is allowed
static inline int has_capability(const MyObject* obj, Capability cap) {
    return obj && (obj->capabilities & cap);
}

int myobject_get_value(const MyObject* obj) {
    if (!has_capability(obj, CAPABILITY_READ)) {
        errno = EACCES;  // Permission denied
        return -1;
    }
    return obj->value;
}

int myobject_set_value(MyObject* obj, int value) {
    if (!has_capability(obj, CAPABILITY_WRITE)) {
        errno = EACCES;
        return -1;
    }
    obj->value = value;
    return 0;
}

// Grant additional capability
int myobject_grant_cap(MyObject* obj, Capability cap) {
    if (!has_capability(obj, CAPABILITY_ADMIN)) {
        errno = EACCES;  // Only admins can grant capabilities
        return -1;
    }
    obj->capabilities |= cap;
    return 0;
}

// Revoke capability
int myobject_revoke_cap(MyObject* obj, Capability cap) {
    if (!has_capability(obj, CAPABILITY_ADMIN)) {
        errno = EACCES;
        return -1;
    }
    obj->capabilities &= ~cap;
    return 0;
}

// Usage example:
MyObject* obj = myobject_create_with_caps(
    CAPABILITY_READ | CAPABILITY_ADMIN
);

myobject_set_value(obj, 42);  // FAILS - no write capability

// Admin grants write
myobject_grant_cap(obj, CAPABILITY_WRITE);

myobject_set_value(obj, 42);  // SUCCESS - now has write

// This is how file descriptors work in UNIX!
// open(path, O_RDONLY) -> read capability only
// open(path, O_RDWR)   -> read + write capabilities
\end{lstlisting}

\section{Pattern: Copy-on-Write (COW) Optimization}

Here's a memory optimization pattern used by strings, arrays, and databases:

\begin{lstlisting}
struct MyObject {
    char* data;
    size_t length;
    size_t capacity;
    uint32_t* ref_count;  // Shared reference count
    uint8_t is_cow;       // Is this a COW reference?
};

// Create new object
MyObject* myobject_create(const char* str) {
    MyObject* obj = malloc(sizeof(MyObject));
    if (!obj) return NULL;

    obj->length = strlen(str);
    obj->capacity = obj->length + 1;
    obj->data = malloc(obj->capacity);
    obj->ref_count = malloc(sizeof(uint32_t));

    if (!obj->data || !obj->ref_count) {
        free(obj->data);
        free(obj->ref_count);
        free(obj);
        return NULL;
    }

    strcpy(obj->data, str);
    *obj->ref_count = 1;
    obj->is_cow = 0;

    return obj;
}

// Cheap copy - shares data buffer
MyObject* myobject_clone(const MyObject* src) {
    if (!src) return NULL;

    MyObject* obj = malloc(sizeof(MyObject));
    if (!obj) return NULL;

    // Share the data buffer!
    obj->data = src->data;
    obj->length = src->length;
    obj->capacity = src->capacity;
    obj->ref_count = src->ref_count;
    obj->is_cow = 1;

    // Increment reference count
    (*obj->ref_count)++;

    return obj;
}

// Make data buffer unique before modifying
static int cow_detach(MyObject* obj) {
    if (!obj->is_cow) return 0;  // Already unique

    if (*obj->ref_count > 1) {
        // Other objects still sharing - need to copy
        char* new_data = malloc(obj->capacity);
        if (!new_data) return -1;

        memcpy(new_data, obj->data, obj->length + 1);

        // Decrement shared ref count
        (*obj->ref_count)--;

        // Create new ref count
        obj->ref_count = malloc(sizeof(uint32_t));
        if (!obj->ref_count) {
            free(new_data);
            return -1;
        }

        *obj->ref_count = 1;
        obj->data = new_data;
    }

    obj->is_cow = 0;  // Now unique
    return 0;
}

// Modify - automatically detaches if needed
int myobject_append(MyObject* obj, const char* str) {
    if (!obj || !str) return -1;

    // Detach from shared buffer
    if (cow_detach(obj) != 0) return -1;

    size_t add_len = strlen(str);
    size_t new_len = obj->length + add_len;

    // Reallocate if needed
    if (new_len + 1 > obj->capacity) {
        size_t new_cap = (new_len + 1) * 2;
        char* new_data = realloc(obj->data, new_cap);
        if (!new_data) return -1;

        obj->data = new_data;
        obj->capacity = new_cap;
    }

    // Append
    strcpy(obj->data + obj->length, str);
    obj->length = new_len;

    return 0;
}

void myobject_destroy(MyObject* obj) {
    if (!obj) return;

    // Decrement ref count
    if (--(*obj->ref_count) == 0) {
        // Last reference - free shared resources
        free(obj->data);
        free(obj->ref_count);
    }

    free(obj);
}

// Example usage:
MyObject* obj1 = myobject_create("hello");  // Allocates buffer

MyObject* obj2 = myobject_clone(obj1);      // Shares buffer - CHEAP!
MyObject* obj3 = myobject_clone(obj1);      // Shares buffer - CHEAP!
// All three point to same "hello" buffer

myobject_append(obj2, " world");            // Detaches - obj2 gets own copy
// Now: obj1 and obj3 share "hello"
//      obj2 has unique "hello world"

// This is how Python strings work!
// And QString in Qt
// And std::string in some C++ implementations
\end{lstlisting}

\begin{tipbox}
COW is perfect for scenarios where most objects are read-only. You save memory by sharing, but pay the detach cost only when actually modifying. Redis uses this for string values!
\end{tipbox}

\section{Pattern: Object Pools (Custom Allocators)}

Professional code often implements custom memory allocators for performance:

\begin{lstlisting}
#define POOL_SIZE 1024

typedef struct {
    MyObject objects[POOL_SIZE];  // Pre-allocated objects
    uint32_t free_bitmap[POOL_SIZE / 32];  // Each bit = free/used
    uint32_t allocated_count;
} ObjectPool;

static ObjectPool g_pool = {0};

// Initialize pool
void myobject_pool_init(void) {
    // Mark all objects as free (bit = 1 means free)
    memset(g_pool.free_bitmap, 0xFF, sizeof(g_pool.free_bitmap));
    g_pool.allocated_count = 0;
}

// Find first free slot using bit operations
static int find_free_slot(void) {
    for (uint32_t i = 0; i < POOL_SIZE / 32; i++) {
        if (g_pool.free_bitmap[i] != 0) {
            // This word has free bits
            int bit = __builtin_ffs(g_pool.free_bitmap[i]) - 1;
            return i * 32 + bit;
        }
    }
    return -1;  // Pool full
}

// Allocate from pool - O(1) and NO malloc()!
MyObject* myobject_create_pooled(void) {
    int idx = find_free_slot();
    if (idx < 0) return NULL;

    // Mark as used
    uint32_t word = idx / 32;
    uint32_t bit = idx % 32;
    g_pool.free_bitmap[word] &= ~(1u << bit);

    g_pool.allocated_count++;

    // Initialize object
    MyObject* obj = &g_pool.objects[idx];
    obj->value = 0;
    obj->name = NULL;

    return obj;
}

// Free to pool - just mark bit, NO free()!
void myobject_destroy_pooled(MyObject* obj) {
    if (!obj) return;

    // Calculate index
    ptrdiff_t idx = obj - g_pool.objects;
    if (idx < 0 || idx >= POOL_SIZE) {
        fprintf(stderr, "ERROR: Object not from pool!\n");
        return;
    }

    // Clean up object
    free(obj->name);
    obj->name = NULL;

    // Mark as free
    uint32_t word = idx / 32;
    uint32_t bit = idx % 32;
    g_pool.free_bitmap[word] |= (1u << bit);

    g_pool.allocated_count--;
}

// Check if pool is from our pool
int myobject_is_pooled(const MyObject* obj) {
    ptrdiff_t idx = obj - g_pool.objects;
    return idx >= 0 && idx < POOL_SIZE;
}

// Get pool statistics
void myobject_pool_stats(void) {
    printf("Pool: %u/%u objects allocated (%.1f%% full)\n",
           g_pool.allocated_count,
           POOL_SIZE,
           100.0 * g_pool.allocated_count / POOL_SIZE);
}

// Benefits:
// - No malloc/free overhead - FAST!
// - No fragmentation
// - Cache-friendly (objects are contiguous)
// - Can iterate all objects easily
// - Easy to debug (dump entire pool)

// Drawbacks:
// - Fixed pool size
// - Wastes memory if pool is too large
// - All objects same size

// Used by:
// - Game engines (object pools everywhere!)
// - Network servers (connection pools)
// - Database systems (page pools)
// - Embedded systems (deterministic allocation)
\end{lstlisting}

\section{Pattern: Intrusive Reference Counting}

Here's how to implement automatic cleanup like COM objects or Objective-C:

\begin{lstlisting}
struct MyObject {
    uint32_t ref_count;     // Must be first for alignment
    int value;
    char* name;
    void (*destructor)(MyObject*);  // Custom cleanup
};

// Create with ref_count = 1
MyObject* myobject_create(void) {
    MyObject* obj = malloc(sizeof(MyObject));
    if (obj) {
        obj->ref_count = 1;  // Caller owns first reference
        obj->value = 0;
        obj->name = NULL;
        obj->destructor = NULL;
    }
    return obj;
}

// Retain - increment ref count
MyObject* myobject_retain(MyObject* obj) {
    if (obj) {
        obj->ref_count++;
    }
    return obj;  // Convenient for chaining
}

// Release - decrement ref count, free if zero
void myobject_release(MyObject* obj) {
    if (!obj) return;

    if (--obj->ref_count == 0) {
        // Call custom destructor if provided
        if (obj->destructor) {
            obj->destructor(obj);
        }

        // Free resources
        free(obj->name);
        free(obj);
    }
}

// Autorelease - release at scope exit (GCC/Clang)
#define myobject_autorelease(obj) \
    __attribute__((cleanup(myobject_release_cleanup))) obj

static inline void myobject_release_cleanup(MyObject** obj_ptr) {
    myobject_release(*obj_ptr);
}

// Usage with automatic cleanup:
void some_function(void) {
    MyObject* myobject_autorelease(obj) = myobject_create();

    // Use obj...

    // obj is automatically released when function returns!
    // Even if you return early or an error occurs
}

// Set custom destructor
void myobject_set_destructor(MyObject* obj, void (*destructor)(MyObject*)) {
    if (obj) {
        obj->destructor = destructor;
    }
}

// Example custom destructor
void custom_cleanup(MyObject* obj) {
    printf("Custom cleanup for object %p\n", (void*)obj);
    // Close files, network connections, etc.
}

// Practical example: shared ownership
void example_shared_ownership(void) {
    MyObject* obj = myobject_create();  // ref_count = 1

    // Thread 1 retains
    pass_to_thread1(myobject_retain(obj));  // ref_count = 2

    // Thread 2 retains
    pass_to_thread2(myobject_retain(obj));  // ref_count = 3

    // Original owner releases
    myobject_release(obj);  // ref_count = 2

    // Object still alive until both threads release!
    // Last thread to call release() will free the object
}

// This is EXACTLY how:
// - COM (Component Object Model) works in Windows
// - Objective-C ARC (Automatic Reference Counting)
// - GObject in GTK+
// - Python reference counting
// And now you understand the magic behind them all!
\end{lstlisting}

\section{Pattern: Weak References}

Sometimes you need to reference an object without keeping it alive:

\begin{lstlisting}
typedef struct WeakRef WeakRef;

struct MyObject {
    uint32_t ref_count;
    WeakRef* weak_refs;  // Linked list of weak references
    int value;
};

struct WeakRef {
    MyObject* target;    // NULL if target was destroyed
    WeakRef* next;       // Next weak ref in list
};

WeakRef* myobject_create_weak_ref(MyObject* obj) {
    if (!obj) return NULL;

    WeakRef* weak = malloc(sizeof(WeakRef));
    if (!weak) return NULL;

    weak->target = obj;

    // Add to object's weak ref list
    weak->next = obj->weak_refs;
    obj->weak_refs = weak;

    return weak;
}

// Try to get strong reference from weak reference
MyObject* weak_ref_lock(WeakRef* weak) {
    if (!weak || !weak->target) {
        return NULL;  // Target was destroyed
    }

    // Upgrade to strong reference
    return myobject_retain(weak->target);
}

void weak_ref_destroy(WeakRef* weak) {
    free(weak);
}

// When destroying object, NULL out all weak refs
void myobject_release(MyObject* obj) {
    if (!obj) return;

    if (--obj->ref_count == 0) {
        // NULL out all weak references
        WeakRef* weak = obj->weak_refs;
        while (weak) {
            weak->target = NULL;  // Now weak refs know object is gone
            weak = weak->next;
        }

        free(obj);
    }
}

// Usage:
MyObject* obj = myobject_create();
WeakRef* weak = myobject_create_weak_ref(obj);

// Later, try to access:
MyObject* strong = weak_ref_lock(weak);
if (strong) {
    // Object still alive!
    myobject_do_something(strong);
    myobject_release(strong);
} else {
    // Object was destroyed
    printf("Object no longer exists\n");
}

// This prevents circular reference problems:
// Parent -> Child (strong)
// Child -> Parent (weak)  // Won't prevent parent from being freed
\end{lstlisting}

\section{Pattern: Tagged Pointers}

On 64-bit systems, pointers only use 48 bits. We can use the unused bits for metadata:

\begin{lstlisting}
// On x86-64, pointers only use lower 48 bits
// Upper 16 bits are unused (sign-extended)
// Lower 3 bits are usually 0 due to alignment

typedef uintptr_t TaggedPtr;

// Tag in lower 3 bits (assumes 8-byte alignment)
#define TAG_MASK     0x7
#define PTR_MASK     (~TAG_MASK)

// Different object types
#define TAG_OBJECT   0
#define TAG_STRING   1
#define TAG_ARRAY    2
#define TAG_NUMBER   3

// Create tagged pointer
static inline TaggedPtr make_tagged(void* ptr, uint8_t tag) {
    uintptr_t addr = (uintptr_t)ptr;
    assert((addr & TAG_MASK) == 0);  // Must be aligned!
    return addr | (tag & TAG_MASK);
}

// Extract pointer
static inline void* tagged_ptr(TaggedPtr tagged) {
    return (void*)(tagged & PTR_MASK);
}

// Extract tag
static inline uint8_t tagged_tag(TaggedPtr tagged) {
    return tagged & TAG_MASK;
}

// Example: universal container
typedef struct {
    TaggedPtr data;  // Can hold different types
} Value;

Value value_create_object(MyObject* obj) {
    Value v;
    v.data = make_tagged(obj, TAG_OBJECT);
    return v;
}

Value value_create_string(char* str) {
    Value v;
    v.data = make_tagged(str, TAG_STRING);
    return v;
}

void value_print(Value v) {
    switch (tagged_tag(v.data)) {
        case TAG_OBJECT: {
            MyObject* obj = tagged_ptr(v.data);
            printf("Object: value=%d\n", obj->value);
            break;
        }
        case TAG_STRING: {
            char* str = tagged_ptr(v.data);
            printf("String: %s\n", str);
            break;
        }
        // ... other types
    }
}

// Save 8 bytes per value by embedding type in pointer!
// Used by:
// - JavaScript engines (V8, SpiderMonkey)
// - Lua interpreter
// - OCaml runtime
// - Many garbage collectors

// Alternative: Use upper bits for flags
#define FLAG_MARKED  (1ULL << 63)  // GC mark bit
#define FLAG_PINNED  (1ULL << 62)  // Can't move in memory
#define FLAG_SHARED  (1ULL << 61)  // Shared between threads

static inline TaggedPtr mark_object(TaggedPtr ptr) {
    return ptr | FLAG_MARKED;
}

static inline int is_marked(TaggedPtr ptr) {
    return (ptr & FLAG_MARKED) != 0;
}

static inline TaggedPtr clear_flags(TaggedPtr ptr) {
    return ptr & 0x0000FFFFFFFFFFFFULL;  // Clear upper 16 bits
}
\end{lstlisting}

\begin{warningbox}
Tagged pointers are architecture-specific and require careful alignment management. Not portable to 32-bit systems. Use with caution! (But they're incredibly powerful when you need them.)
\end{warningbox}

\section{Pattern: Intrusive Containers}

Instead of wrapping objects in container nodes, embed the links in the objects themselves:

\begin{lstlisting}
// Traditional approach (non-intrusive):
typedef struct Node {
    void* data;          // Separate allocation
    struct Node* next;
} Node;

// Intrusive approach - embed links in object
struct MyObject {
    int value;
    char* name;

    // Intrusive list links
    MyObject* next;
    MyObject* prev;
};

// List operations don't need malloc!
void list_append(MyObject** head, MyObject* obj) {
    obj->next = NULL;
    obj->prev = NULL;

    if (*head == NULL) {
        *head = obj;
    } else {
        MyObject* tail = *head;
        while (tail->next) {
            tail = tail->next;
        }
        tail->next = obj;
        obj->prev = tail;
    }
}

void list_remove(MyObject** head, MyObject* obj) {
    if (obj->prev) {
        obj->prev->next = obj->next;
    } else {
        *head = obj->next;  // Was head
    }

    if (obj->next) {
        obj->next->prev = obj->prev;
    }

    obj->next = NULL;
    obj->prev = NULL;
}

// Iterate - simple pointer chasing
void list_print(MyObject* head) {
    for (MyObject* obj = head; obj; obj = obj->next) {
        printf("Object: %d\n", obj->value);
    }
}

// Benefits:
// - No extra allocations
// - Better cache locality
// - Faster operations
// - Object can be in multiple lists!

// Multiple list support:
struct MyObject {
    int value;

    // Can be in two lists at once!
    struct {
        MyObject* next;
        MyObject* prev;
    } list1;

    struct {
        MyObject* next;
        MyObject* prev;
    } list2;
};

// This is EXACTLY how the Linux kernel list works!
// See: include/linux/list.h
// Container of is the magic macro that makes it work

#define container_of(ptr, type, member) \
    ((type *)((char *)(ptr) - offsetof(type, member)))

// Example: generic list node
typedef struct ListHead {
    struct ListHead* next;
    struct ListHead* prev;
} ListHead;

// Embed in your struct
struct MyObject {
    int value;
    ListHead list_node;  // Intrusive list node
};

// Get object from list node
#define list_entry(ptr, type, member) \
    container_of(ptr, type, member)

// Usage:
ListHead* node = /* some list node */;
MyObject* obj = list_entry(node, MyObject, list_node);
printf("Value: %d\n", obj->value);
\end{lstlisting}

\section{Summary}

The opaque pointer pattern is the cornerstone of professional C development:

\begin{itemize}
    \item Provides true encapsulation in C
    \item Enables ABI stability for shared libraries
    \item Allows multiple implementations behind single interface
    \item Prevents users from breaking invariants
    \item Reduces compilation dependencies
    \item Enables polymorphism via VTables
    \item Used by virtually every major C library
\end{itemize}

\textbf{Advanced patterns covered:}
\begin{itemize}
    \item Handle tables with generational IDs (use-after-free detection)
    \item Capability-based security (fine-grained permissions)
    \item Copy-on-write optimization (memory efficiency)
    \item Object pools (custom allocators for performance)
    \item Intrusive reference counting (automatic cleanup)
    \item Weak references (prevent circular dependencies)
    \item Tagged pointers (metadata in unused bits)
    \item Intrusive containers (Linux kernel style)
\end{itemize}

Master these patterns and you'll write C code that's maintainable, stable, and professional-grade. It's the difference between hobby code and production systems that run for decades. It's also the difference between "works on my machine" and "works on everyone's machine for the next 20 years."

\vspace{1em}

Now go forth and make your structs opaque. Your future self (and your users) will thank you. Probably with fewer bug reports and angry emails.

\begin{tipbox}
Next time you use \texttt{FILE*}, \texttt{DIR*}, \texttt{pthread\_t}, or any OpenSSL type, remember: you're using opaque pointers. This pattern has powered the world's most critical software for 50+ years. Learn it well. (It's older than most programming languages. That's not old, that's battle-tested.)
\end{tipbox}
